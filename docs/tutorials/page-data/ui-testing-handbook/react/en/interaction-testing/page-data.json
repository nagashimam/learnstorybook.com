{"componentChunkName":"component---src-components-screens-chapter-screen-index-js","path":"/ui-testing-handbook/react/en/interaction-testing/","result":{"data":{"currentPage":{"html":"<p>You flip the switch, and the light doesn’t turn on. It could be a burnt-out light bulb, or it could be faulty wiring. The switch and the bulb are connected to each other with wires inside the walls.</p>\n<p>Apps are the same. On the surface is the UI that the user sees and interacts with. Under the hood, the UI is wired up to facilitate the flow of data and events.</p>\n<p>As you build more complex UIs like pages, components become responsible for more than just rendering the UI. They fetch data and manage state. This chapter will teach you how to use a computer to simulate and verify user interactions.</p>\n<p><img src=\"/tutorials/ui-testing-handbook/1_bfTfHf-9RSQ_s3FhnRBaeQ.png\" alt=\"\"></p>\n<h2>Does that component really work?</h2>\n<p>A component's primary task is to render a piece of the UI given a set of props. More complex components also track application state and pass behaviours down the component tree.</p>\n<p>For example, a component will start with an initial state. When the user types something in an input field or clicks a button, it triggers an event within the app. The component updates state in response to this event. Those state changes then update the rendered UI. That's the complete cycle for an interaction.</p>\n<p>On the <code>InboxScreen</code>, the user can click on the star icon to pin a task. Or click on the checkbox to archive it. Visual tests ensure that the component looks right in all those states. We also need to ensure that the UI is responding to those interactions correctly.</p>\n<p><img src=\"/tutorials/ui-testing-handbook/interactive-taskbox.gif\" alt=\"\"></p>\n<h2>How does component testing in Storybook work?</h2>\n<p>Testing interactions is a widespread pattern for verifying user behavior. You provide mock data to set up a test scenario, simulate user interactions using <a href=\"https://testing-library.com/\">Testing Library</a>, and check the resultant DOM structure.</p>\n<p><img src=\"/tutorials/ui-testing-handbook/1_AyDgC9kxOjUl8Yihq0ltTQ.gif\" alt=\"\"></p>\n<p>In Storybook, this familiar workflow happens in your browser. That makes it easier to debug failures because you're running tests in the same environment as you develop components—the browser.</p>\n<p>We'll start by writing a <strong>story</strong> to set up the component's initial state. Then simulate user behavior such as clicks and form entries using the <strong>play function</strong>. Finally, use the Storybook <strong>test runner</strong> to check whether the UI and component state update correctly.</p>\n<h2>Setup the test runner</h2>\n<p>Run the following command to install it:</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`yarn add --dev @storybook/test-runner`, `57249470918127860000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"57249470918127860000\"\n              >\n                Copy \n              </div>\n            </div>\n<pre><code class=\"language-shell\">yarn add --dev @storybook/test-runner\n</code></pre>\n<p>Then add a test task to your project’s <code>package.json</code>:</p>\n<pre><code class=\"language-json\">{\n  \"scripts\": {\n    \"test-storybook\": \"test-storybook\"\n  }\n}\n</code></pre>\n<p>Lastly, start up your Storybook (the test runner will run against your local Storybook instance):</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`yarn storybook`, `27633487056827044000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"27633487056827044000\"\n              >\n                Copy \n              </div>\n            </div>\n<pre><code class=\"language-shell\">yarn storybook\n</code></pre>\n<h2>Reuse stories as interaction test cases</h2>\n<p>In the previous chapter, we catalogued all the use cases of the InboxScreen component in the <code>InboxScreen.stories.js</code> file. That allowed us to spot-check appearance during development and catch regressions via visual tests. These stories will now also power our interaction tests.</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`import { rest } from 'msw';\n\nimport InboxScreen from './InboxScreen';\n\nimport { Default as TaskListDefault } from './components/TaskList.stories';\n\nexport default {\n  component: InboxScreen,\n  title: 'InboxScreen',\n};\n\nexport const Default = {\n  parameters: {\n    msw: {\n      handlers: [\n        rest.get('/tasks', (req, res, ctx) => {\n          return res(ctx.json(TaskListDefault.args));\n        }),\n      ],\n    },\n  },\n};\n\nexport const Error = {\n  args: {\n    error: 'Something',\n  },\n  parameters: {\n    msw: {\n      handlers: [\n        rest.get('/tasks', (req, res, ctx) => {\n          return res(ctx.json([]));\n        }),\n      ],\n    },\n  },\n};`, `82939898985562360000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"82939898985562360000\"\n              >\n                Copy \n              </div>\n            </div>\n<div class=\"gatsby-code-title\">src/InboxScreen.stories.jsx</div>\n<pre><code class=\"language-javascript\">import { rest } from 'msw';\n\nimport InboxScreen from './InboxScreen';\n\nimport { Default as TaskListDefault } from './components/TaskList.stories';\n\nexport default {\n  component: InboxScreen,\n  title: 'InboxScreen',\n};\n\nexport const Default = {\n  parameters: {\n    msw: {\n      handlers: [\n        rest.get('/tasks', (req, res, ctx) => {\n          return res(ctx.json(TaskListDefault.args));\n        }),\n      ],\n    },\n  },\n};\n\nexport const Error = {\n  args: {\n    error: 'Something',\n  },\n  parameters: {\n    msw: {\n      handlers: [\n        rest.get('/tasks', (req, res, ctx) => {\n          return res(ctx.json([]));\n        }),\n      ],\n    },\n  },\n};\n</code></pre>\n<h3>Write an interaction test using the play function</h3>\n<p><a href=\"https://testing-library.com/\">Testing Library</a> offers a convenient API for simulating user interactions—click, drag, tap, type, etc. Whereas <a href=\"https://jestjs.io/\">Jest</a> provides assertion utilities. We'll use Storybook-instrumented versions of these two tools to write the test. Therefore, you get a familiar developer-friendly syntax to interact with the DOM, but with extra telemetry to help with debugging.</p>\n<p>The test itself will be housed inside a <a href=\"https://storybook.js.org/docs/react/writing-stories/play-function\">play function</a>. This snippet of code gets attached to a story and runs after the story is rendered.</p>\n<p>Let's add in our first interaction test to verify that the user can pin a task:</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`import { rest } from 'msw';\n\nimport InboxScreen from './InboxScreen';\n\nimport { Default as TaskListDefault } from './components/TaskList.stories';\n\nimport { within, userEvent, findByRole } from '@storybook/testing-library';\n\nimport { expect } from '@storybook/jest';\n\n// ... code omitted for brevity ...\n\nexport const PinTask = {\n  parameters: {\n    ...Default.parameters,\n  },\n  play: async ({ canvasElement }) => {\n    const canvas = within(canvasElement);\n    const getTask = (id) => canvas.findByRole('listitem', { name: id });\n\n    const itemToPin = await getTask('task-4');\n    // Find the pin button\n    const pinButton = await findByRole(itemToPin, 'button', { name: 'pin' });\n    // Click the pin button\n    await userEvent.click(pinButton);\n    // Check that the pin button is now a unpin button\n    const unpinButton = within(itemToPin).getByRole('button', {\n      name: 'unpin',\n    });\n    await expect(unpinButton).toBeInTheDocument();\n  },\n};`, `30070172160798724000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"30070172160798724000\"\n              >\n                Copy \n              </div>\n            </div>\n<div class=\"gatsby-code-title\">src/InboxScreen.stories.jsx</div>\n<pre><code class=\"language-javascript\">import { rest } from 'msw';\n\nimport InboxScreen from './InboxScreen';\n\nimport { Default as TaskListDefault } from './components/TaskList.stories';\n\nimport { within, userEvent, findByRole } from '@storybook/testing-library';\n\nimport { expect } from '@storybook/jest';\n\n// ... code omitted for brevity ...\n\nexport const PinTask = {\n  parameters: {\n    ...Default.parameters,\n  },\n  play: async ({ canvasElement }) => {\n    const canvas = within(canvasElement);\n    const getTask = (id) => canvas.findByRole('listitem', { name: id });\n\n    const itemToPin = await getTask('task-4');\n    // Find the pin button\n    const pinButton = await findByRole(itemToPin, 'button', { name: 'pin' });\n    // Click the pin button\n    await userEvent.click(pinButton);\n    // Check that the pin button is now a unpin button\n    const unpinButton = within(itemToPin).getByRole('button', {\n      name: 'unpin',\n    });\n    await expect(unpinButton).toBeInTheDocument();\n  },\n};\n</code></pre>\n<p>Each play function receives the Canvas element—the top-level container of the story. You can scope your queries to just within this element, making it easier to find DOM nodes.</p>\n<p>We're looking for the \"Export logo\" task in our case. Then find the pin button within it and click it. Finally, we check to see if the button has updated to the unpinned state.</p>\n<p>When Storybook finishes rendering the story, it executes the steps defined within the play function, interacting with the component and pinning a task—similar to how a user would do it. If you check your <a href=\"https://storybook.js.org/docs/react/writing-tests/interaction-testing#interactive-debugger\">interactions panel</a>, you'll see the step-by-step flow. It also offers a handy set of UI controls to pause, resume, rewind, and step through each interaction.</p>\n<video autoPlay muted playsInline loop>\n  <source\n    src=\"/tutorials/ui-testing-handbook/pin-task-7-0.mp4\"\n    type=\"video/mp4\"\n  />\n</video>\n<h3>Execute tests with test runner</h3>\n<p>Now that we have our first test down, let's go ahead and add tests for the archive and edit task functionalities.</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`// ... code omitted for brevity ...\n\nexport const ArchiveTask = {\n  parameters: {\n    ...Default.parameters,\n  },\n  play: async ({ canvasElement }) => {\n    const canvas = within(canvasElement);\n    const getTask = (id) => canvas.findByRole('listitem', { name: id });\n\n    const itemToArchive = await getTask('task-2');\n    const archiveButton = await findByRole(itemToArchive, 'button', {\n      name: 'archiveButton-2',\n    });\n    await userEvent.click(archiveButton);\n  },\n};\n\nexport const EditTask = {\n  parameters: {\n    ...Default.parameters,\n  },\n  play: async ({ canvasElement }) => {\n    const canvas = within(canvasElement);\n    const getTask = (id) => canvas.findByRole('listitem', { name: id });\n\n    const itemToEdit = await getTask('task-5');\n    const taskInput = await findByRole(itemToEdit, 'textbox');\n    await userEvent.type(taskInput, ' and disabled state');\n    await expect(taskInput.value).toBe(\n      'Fix bug in input error state and disabled state'\n    );\n  },\n};`, `32120451823640228000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"32120451823640228000\"\n              >\n                Copy \n              </div>\n            </div>\n<div class=\"gatsby-code-title\">src/InboxScreen.stories.jsx</div>\n<pre><code class=\"language-javascript\">// ... code omitted for brevity ...\n\nexport const ArchiveTask = {\n  parameters: {\n    ...Default.parameters,\n  },\n  play: async ({ canvasElement }) => {\n    const canvas = within(canvasElement);\n    const getTask = (id) => canvas.findByRole('listitem', { name: id });\n\n    const itemToArchive = await getTask('task-2');\n    const archiveButton = await findByRole(itemToArchive, 'button', {\n      name: 'archiveButton-2',\n    });\n    await userEvent.click(archiveButton);\n  },\n};\n\nexport const EditTask = {\n  parameters: {\n    ...Default.parameters,\n  },\n  play: async ({ canvasElement }) => {\n    const canvas = within(canvasElement);\n    const getTask = (id) => canvas.findByRole('listitem', { name: id });\n\n    const itemToEdit = await getTask('task-5');\n    const taskInput = await findByRole(itemToEdit, 'textbox');\n    await userEvent.type(taskInput, ' and disabled state');\n    await expect(taskInput.value).toBe(\n      'Fix bug in input error state and disabled state'\n    );\n  },\n};\n</code></pre>\n<p>You should now see stories for these scenarios. Storybook only runs the interaction test when you’re viewing a story. Therefore, you'd have to go through each story to run all your checks.</p>\n<p>It's unrealistic to manually review the entire Storybook whenever you make a change. Storybook test runner automates that process. It's a standalone utility—powered by <a href=\"https://playwright.dev/\">Playwright</a>—that runs all your interactions tests and catches broken stories.</p>\n<p><img src=\"/tutorials/ui-testing-handbook/inbox-screen-interaction-test.png\" alt=\"\"></p>\n<p>Start the test runner (in a separate terminal window):</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`yarn test-storybook --watch`, `99163793172062200000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"99163793172062200000\"\n              >\n                Copy \n              </div>\n            </div>\n<pre><code class=\"language-shell\">yarn test-storybook --watch\n</code></pre>\n<p><img src=\"/tutorials/ui-testing-handbook/test-runner.png\" alt=\"\"></p>\n<p>It'll verify whether all stories rendered without any errors and that all assertions are passed. If a test fails, you get a link that opens up the failing story in the browser.</p>\n<p><img src=\"/tutorials/ui-testing-handbook/storybook-test-runner-story-error.png\" alt=\"\"></p>\n<p>In summary, the setup code and test both collocated in the stories file. Using a play function, we interacted with the UI the way a user would. Storybook interaction tests combine the intuitive debugging environment of a live browser with the performance and scriptability of headless browsers.</p>\n<h2>Catching usability issues</h2>\n<p>When you ensure your UI is usable to every user, you impact the business financials and satisfy <a href=\"https://www.w3.org/WAI/policies/?q=government\">legal requirements</a>. It’s a win-win. The next chapter demonstrates how you can leverage the portability of stories to simplify accessibility testing.</p>","frontmatter":{"title":"Testing component interactions","description":"Learn how to simulate user behaviour and run functional checks","commit":"fa3353e"},"fields":{"guide":"ui-testing-handbook","slug":"/ui-testing-handbook/react/en/interaction-testing/","chapter":"interaction-testing","framework":"react","language":"en","permalink":"https://storybook.js.org/tutorials/ui-testing-handbook/react/en/interaction-testing/","tutorialUpToDate":true}},"currentGuide":{"frontmatter":{"codeGithubUrl":"https://github.com/chromaui/ui-testing-guide-code","toc":["introduction","visual-testing","composition-testing","interaction-testing","accessibility-testing","user-flow-testing","automate","workflow","conclusion"],"title":"UI Testing Handbook","twitterShareText":"I'm learning how to test UIs! This will help me ship UIs without worrying about stowaway bugs."}},"site":{"siteMetadata":{"title":"Storybook Tutorials","githubUrl":"https://github.com/chromaui/learnstorybook.com","contributeUrl":"https://github.com/chromaui/learnstorybook.com/#contribute","permalink":"https://storybook.js.org/tutorials","siteUrl":"https://storybook.js.org"}},"tocPages":{"edges":[{"node":{"frontmatter":{"tocTitle":"Accessibility","title":"Accessibility testing with Storybook","description":"Fast feedback with integrated tooling"},"fields":{"slug":"/ui-testing-handbook/react/en/accessibility-testing/","framework":"react","chapter":"accessibility-testing"}}},{"node":{"frontmatter":{"tocTitle":"Automate","title":"How to automate UI tests with Github Actions","description":"Speed up your workflow and ship higher quality of code"},"fields":{"slug":"/ui-testing-handbook/react/en/automate/","framework":"react","chapter":"automate"}}},{"node":{"frontmatter":{"tocTitle":"Conclusion","title":"Conclusion","description":"Get more done by doing less"},"fields":{"slug":"/ui-testing-handbook/react/en/conclusion/","framework":"react","chapter":"conclusion"}}},{"node":{"frontmatter":{"tocTitle":"Interaction","title":"Testing component interactions","description":"Learn how to simulate user behaviour and run functional checks"},"fields":{"slug":"/ui-testing-handbook/react/en/interaction-testing/","framework":"react","chapter":"interaction-testing"}}},{"node":{"frontmatter":{"tocTitle":"Introduction","title":"Introduction to testing UIs","description":"Latest production-ready techniques for testing UIs"},"fields":{"slug":"/ui-testing-handbook/react/en/introduction/","framework":"react","chapter":"introduction"}}},{"node":{"frontmatter":{"tocTitle":"User flow","title":"Testing user flows","description":"Verify that your UI works end-to-end"},"fields":{"slug":"/ui-testing-handbook/react/en/user-flow-testing/","framework":"react","chapter":"user-flow-testing"}}},{"node":{"frontmatter":{"tocTitle":"Visual","title":"Visual testing in Storybook","description":"Learn how to pinpoint UI bugs automatically"},"fields":{"slug":"/ui-testing-handbook/react/en/visual-testing/","framework":"react","chapter":"visual-testing"}}},{"node":{"frontmatter":{"tocTitle":"Workflow","title":"UI Testing Playbook","description":"A testing workflow that doesn’t slow you down"},"fields":{"slug":"/ui-testing-handbook/react/en/workflow/","framework":"react","chapter":"workflow"}}},{"node":{"frontmatter":{"tocTitle":"Composition","title":"Testing composite components","description":"Prevent minor changes from turning into major regressions"},"fields":{"slug":"/ui-testing-handbook/react/en/composition-testing/","framework":"react","chapter":"composition-testing"}}}]},"translationPages":{"edges":[{"node":{"frontmatter":{"tocTitle":"Accessibility","title":"Accessibility testing with Storybook","description":"Fast feedback with integrated tooling"},"fields":{"slug":"/ui-testing-handbook/react/en/accessibility-testing/","framework":"react","chapter":"accessibility-testing","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Automate","title":"How to automate UI tests with Github Actions","description":"Speed up your workflow and ship higher quality of code"},"fields":{"slug":"/ui-testing-handbook/react/en/automate/","framework":"react","chapter":"automate","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Conclusion","title":"Conclusion","description":"Get more done by doing less"},"fields":{"slug":"/ui-testing-handbook/react/en/conclusion/","framework":"react","chapter":"conclusion","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Interaction","title":"Testing component interactions","description":"Learn how to simulate user behaviour and run functional checks"},"fields":{"slug":"/ui-testing-handbook/react/en/interaction-testing/","framework":"react","chapter":"interaction-testing","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Introduction","title":"Introduction to testing UIs","description":"Latest production-ready techniques for testing UIs"},"fields":{"slug":"/ui-testing-handbook/react/en/introduction/","framework":"react","chapter":"introduction","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"User flow","title":"Testing user flows","description":"Verify that your UI works end-to-end"},"fields":{"slug":"/ui-testing-handbook/react/en/user-flow-testing/","framework":"react","chapter":"user-flow-testing","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Visual","title":"Visual testing in Storybook","description":"Learn how to pinpoint UI bugs automatically"},"fields":{"slug":"/ui-testing-handbook/react/en/visual-testing/","framework":"react","chapter":"visual-testing","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Workflow","title":"UI Testing Playbook","description":"A testing workflow that doesn’t slow you down"},"fields":{"slug":"/ui-testing-handbook/react/en/workflow/","framework":"react","chapter":"workflow","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"접근성","title":"스토리북(Storybook)을 통한 접근성 테스트","description":"통합적인 툴 사용(integrated tooling)으로 빠른 피드백 제공"},"fields":{"slug":"/ui-testing-handbook/react/ko/accessibility-testing/","framework":"react","chapter":"accessibility-testing","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"자동화(Automate)","title":"깃허브(Github) 액션으로 UI 테스트 자동화하기","description":"작업 흐름(workflow)을 더 빠르게 만들고, 더 고품질의 코드를 전달하기"},"fields":{"slug":"/ui-testing-handbook/react/ko/automate/","framework":"react","chapter":"automate","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"구성","title":"구성 테스트","description":"사소한 변경이 커다란 회귀로 변하는 것을 방지하기"},"fields":{"slug":"/ui-testing-handbook/react/ko/composition-testing/","framework":"react","chapter":"composition-testing","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"마무리","title":"마무리","description":"적게 손대고 더 많은 게 해결되도록 하자"},"fields":{"slug":"/ui-testing-handbook/react/ko/conclusion/","framework":"react","chapter":"conclusion","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"상호작용","title":"컴포넌트 상호작용 테스트하기","description":"사용자의 동작을 시뮬레이션하고 기능별 검사를 실행하는 방법 알아보기"},"fields":{"slug":"/ui-testing-handbook/react/ko/interaction-testing/","framework":"react","chapter":"interaction-testing","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"소개","title":"UI 테스트 소개","description":"UI 테스트를 위한 최신 개발 방법"},"fields":{"slug":"/ui-testing-handbook/react/ko/introduction/","framework":"react","chapter":"introduction","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"사용자 플로우(User flow)","title":"사용자 플로우(user flow) 테스트하기","description":"UI가 전체적으로 작동하는지 확인해보세요"},"fields":{"slug":"/ui-testing-handbook/react/ko/user-flow-testing/","framework":"react","chapter":"user-flow-testing","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"시각적 요소 테스트","title":"스토리북(Storybook)의 시각적 요소 테스트","description":"UI 버그를 자동으로 찾아내는 방법 알아보기"},"fields":{"slug":"/ui-testing-handbook/react/ko/visual-testing/","framework":"react","chapter":"visual-testing","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"작업 흐름(Workflow)","title":"UI 테스팅 플레이북","description":"우리를 느리게 하지 않는 테스팅 작업 흐름(workflow)"},"fields":{"slug":"/ui-testing-handbook/react/ko/workflow/","framework":"react","chapter":"workflow","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"Composition","title":"Testing composite components","description":"Prevent minor changes from turning into major regressions"},"fields":{"slug":"/ui-testing-handbook/react/en/composition-testing/","framework":"react","chapter":"composition-testing","language":"en"}}}]}},"pageContext":{"guide":"ui-testing-handbook","slug":"/ui-testing-handbook/react/en/interaction-testing/","framework":"react","language":"en","chapter":"interaction-testing","pageType":"chapter"}},"staticQueryHashes":["238248339"]}