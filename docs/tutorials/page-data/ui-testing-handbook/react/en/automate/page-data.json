{"componentChunkName":"component---src-components-screens-chapter-screen-index-js","path":"/ui-testing-handbook/react/en/automate/","result":{"data":{"currentPage":{"html":"<p>Developers spend <a href=\"https://www.niss.org/sites/default/files/technicalreports/tr81.pdf\">4-8 hrs a week</a> fixing bugs. Things only get worse if a bug sneaks its way into production. It takes <a href=\"https://www.cs.umd.edu/projects/SoftEng/ESEG/papers/82.78.pdf\">5-10x</a> longer to fix it. That's why UI testing is integral to delivering high-quality experiences, but it can also be a huge time sink. It's too much work to run all your tests manually after every change.</p>\n<p>You can automate your workflow to trigger tests when a developer pushes code. The tests execute in the background and report results on completion. That allows you to detect regressions automatically.</p>\n<p>This chapter shows you how to implement such a workflow with <a href=\"https://github.com/features/actions\">Github Actions</a>. Along the way, I'll point out ways to optimize your test runs.</p>\n<h2>Continuous UI testing</h2>\n<p>Reviewing code is a big part of being a developer. It helps catch bugs early and maintains high code quality.</p>\n<p>To ensure that a pull request (PR) won't break production, you’d typically pull code and run the test suite locally. That disrupts your workflow and takes a lot of time. With Continuous Integration (CI), you get all the benefits of testing without any manual intervention.</p>\n<p>You can tweak the UI, build a new feature, or update a dependency. When you open a pull request, the CI server will automatically run comprehensive UI tests—visual, composition, accessibility, interaction and user flows.</p>\n<p>You’ll get test results via PR badges, which provide a summary of all the checks.</p>\n<p><img src=\"/tutorials/ui-testing-handbook/image-19.png\" alt=\"\"></p>\n<p>At a glance, you can tell if the pull request passed all quality checks. If yes, move on to reviewing the actual code. If not, dive into the logs to find out what’s wrong.</p>\n<blockquote>\n<p>\"Testing gives me full confidence for automated dependency updates. If tests pass, we merge them in.\"</p>\n<p>— <a href=\"https://github.com/SiTaggart\">Simon Taggart</a>, Principal Engineer at Twilio</p>\n</blockquote>\n<h2>Tutorial</h2>\n<p>The previous five chapters demonstrated how to test the various aspects of the Taskbox UI. Building on that, we’ll set up continuous integration using GitHub Actions.</p>\n<h3>Set up CI</h3>\n<p>Create a <code>.github/workflows/ui-tests.yml</code> file in your repository to get started. A <a href=\"https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions#workflows\"><strong>workflow</strong></a> is a set of <a href=\"https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions#jobs\"><strong>jobs</strong></a> that you want to automate. It is triggered by <a href=\"https://docs.github.com/en/actions/learn-github-actions/events-that-trigger-workflows\"><strong>events</strong></a> such as pushing a commit or creating a pull request.</p>\n<p>Our workflow will run when code is pushed to any branch of our repository and it’ll have three jobs:</p>\n<ul>\n<li>Run interaction and the accessibility tests with the Storybook test runner</li>\n<li>Run visual and composition tests with Chromatic</li>\n<li>Run user flow tests with Cypress</li>\n</ul>\n<pre><code class=\"language-yaml\">name: 'UI Tests'\n\non: push\n\njobs:\n  # Run interaction and accessibility tests\n  interaction-and-accessibility:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: actions/setup-node@v2\n        with:\n          node-version: '16.x'\n      - name: Install dependencies\n        run: yarn\n      - name: Install Playwright\n        run: npx playwright install --with-deps\n      - name: Build Storybook\n        run: yarn build-storybook --quiet\n      - name: Serve Storybook and run tests\n        run: |\n          npx concurrently -k -s first -n \"SB,TEST\" -c \"magenta,blue\" \\\n            \"npx http-server storybook-static --port 6006 --silent\" \\\n            \"npx wait-on tcp:6006 &#x26;&#x26; yarn test-storybook\"\n  # Run visual and composition tests with Chromatic\n  visual-and-composition:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n        with:\n          fetch-depth: 0 # Required to retrieve git history\n      - name: Install dependencies\n        run: yarn\n      - name: Publish to Chromatic\n        uses: chromaui/action@v1\n        with:\n          # Grab this from the Chromatic manage page\n          projectToken: ${{ secrets.CHROMATIC_PROJECT_TOKEN }}\n  # Run user flow tests with Cypress\n  user-flow:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Install dependencies\n        run: yarn\n      - name: Cypress run\n        uses: cypress-io/github-action@v4\n        with:\n          start: npm run dev\n</code></pre>\n<p>Couple of things to note here. For the test runner, we're using a combination of <a href=\"https://www.npmjs.com/package/concurrently\">concurrently</a>, <a href=\"https://www.npmjs.com/package/http-server\">http-server</a> and <a href=\"https://www.npmjs.com/package/wait-on\">wait-on</a> libraries to build and serve the Storybook to run tests against it.</p>\n<p>And to run Chromatic, you’ll need the <code>CHROMATIC_PROJECT_TOKEN</code>. You can grab it from the Chromatic manage page and <a href=\"https://docs.github.com/en/actions/reference/encrypted-secrets\">add it</a> to your repository secrets.</p>\n<figure style=\"display: flex;\">\n  <img style=\"flex: 1 1 auto; min-width: 0; margin-right: 0.5em;\" src=\"/tutorials/ui-testing-handbook/get-token.png\" alt=\"get project token from Chromatic\" />\n  <img style=\"flex: 1 1 auto; min-width: 0;\" src=\"/tutorials/ui-testing-handbook/add-secret.png\" alt=\"add secret to your repository\" />\n</figure>\n<p>Finally, create a new commit, push your changes to GitHub, and you should see your workflow in action!</p>\n<p><img src=\"/tutorials/ui-testing-handbook/image-21.png\" alt=\"\"></p>\n<h3>Cache dependencies</h3>\n<p>Each job runs independently, which means the CI server has to install dependencies in all three jobs. That slows down the test run. We can cache dependencies and only run <code>yarn install</code> if the lock file changes to avoid that. Let’s update the workflow to include the <code>install-cache</code> job.</p>\n<pre><code class=\"language-yaml\">name: 'UI Tests'\n\non: push\n\njobs:\n  # Install and cache npm dependencies\n  install-cache:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout Commit\n        uses: actions/checkout@v2\n      - name: Cache yarn dependencies and cypress\n        uses: actions/cache@v2\n        id: yarn-cache\n        with:\n          path: |\n            ~/.cache/Cypress\n            node_modules\n          key: ${{ runner.os }}-yarn-v1-${{ hashFiles('**/yarn.lock') }}\n          restore-keys: |\n            ${{ runner.os }}-yarn-v1\n      - name: Install dependencies if cache invalid\n        if: steps.yarn-cache.outputs.cache-hit != 'true'\n        run: yarn\n  # Run interaction and accessibility tests\n  interaction-and-accessibility:\n    runs-on: ubuntu-latest\n    needs: install-cache\n    steps:\n      - uses: actions/checkout@v2\n      - uses: actions/setup-node@v2\n        with:\n          node-version: '16.x'\n      - name: Restore yarn dependencies\n        uses: actions/cache@v2\n        id: yarn-cache\n        with:\n          path: |\n            ~/.cache/Cypress\n            node_modules\n          key: ${{ runner.os }}-yarn-v1-${{ hashFiles('**/yarn.lock') }}\n          restore-keys: |\n            ${{ runner.os }}-yarn-v1\n      - name: Install Playwright\n        run: npx playwright install --with-deps\n      - name: Build Storybook\n        run: yarn build-storybook --quiet\n      - name: Serve Storybook and run tests\n        run: |\n          npx concurrently -k -s first -n \"SB,TEST\" -c \"magenta,blue\" \\\n            \"npx http-server storybook-static --port 6006 --silent\" \\\n            \"npx wait-on tcp:6006 &#x26;&#x26; yarn test-storybook\"\n  # Run visual and composition tests with Chromatic\n  visual-and-composition:\n    runs-on: ubuntu-latest\n    needs: install-cache\n    steps:\n      - uses: actions/checkout@v2\n        with:\n          fetch-depth: 0 # Required to retrieve git history\n      - name: Restore yarn dependencies\n        uses: actions/cache@v2\n        id: yarn-cache\n        with:\n          path: |\n            ~/.cache/Cypress\n            node_modules\n          key: ${{ runner.os }}-yarn-v1-${{ hashFiles('**/yarn.lock') }}\n          restore-keys: |\n            ${{ runner.os }}-yarn-v1\n      - name: Publish to Chromatic\n        uses: chromaui/action@v1\n        with:\n          # Grab this from the Chromatic manage page\n          projectToken: ${{ secrets.CHROMATIC_PROJECT_TOKEN }}\n  # Run user flow tests with Cypress\n  user-flow:\n    runs-on: ubuntu-latest\n    needs: install-cache\n    steps:\n      - uses: actions/checkout@v2\n      - name: Restore yarn dependencies\n        uses: actions/cache@v2\n        id: yarn-cache\n        with:\n          path: |\n            ~/.cache/Cypress\n            node_modules\n          key: ${{ runner.os }}-yarn-v1-${{ hashFiles('**/yarn.lock') }}\n          restore-keys: |\n            ${{ runner.os }}-yarn-v1\n      - name: Cypress run\n        uses: cypress-io/github-action@v4\n        with:\n          start: npm run dev\n</code></pre>\n<p>We also tweaked the other three jobs to wait for the <code>install-cache</code> job to complete to use the cached dependencies. Push another commit to re-run the workflow.</p>\n<p>Success! You’ve automated your testing workflow. When you open up a PR it’ll run the test runner, Chromatic and Cypress in parallel and display the results on the PR page itself.</p>\n<p><img src=\"/tutorials/ui-testing-handbook/image-22.png\" alt=\"\"></p>\n<h2>Mastering the UI testing workflow</h2>\n<p>The testing workflow starts by isolating components using Storybook. Then run checks while you code to get a faster feedback loop. Finally, execute your entire test suite using continuous integration.</p>\n<p>Chapter 8 illustrates this complete workflow in action. We'll see how to test a new feature before shipping it to prod.</p>","frontmatter":{"title":"How to automate UI tests with Github Actions","description":"Speed up your workflow and ship higher quality of code","commit":"c5c2d6d"},"fields":{"guide":"ui-testing-handbook","slug":"/ui-testing-handbook/react/en/automate/","chapter":"automate","framework":"react","language":"en","permalink":"https://storybook.js.org/tutorials/ui-testing-handbook/react/en/automate/","tutorialUpToDate":true}},"currentGuide":{"frontmatter":{"codeGithubUrl":"https://github.com/chromaui/ui-testing-guide-code","toc":["introduction","visual-testing","composition-testing","interaction-testing","accessibility-testing","user-flow-testing","automate","workflow","conclusion"],"title":"UI Testing Handbook","twitterShareText":"I'm learning how to test UIs! This will help me ship UIs without worrying about stowaway bugs."}},"site":{"siteMetadata":{"title":"Storybook Tutorials","githubUrl":"https://github.com/chromaui/learnstorybook.com","contributeUrl":"https://github.com/chromaui/learnstorybook.com/#contribute","permalink":"https://storybook.js.org/tutorials","siteUrl":"https://storybook.js.org"}},"tocPages":{"edges":[{"node":{"frontmatter":{"tocTitle":"Accessibility","title":"Accessibility testing with Storybook","description":"Fast feedback with integrated tooling"},"fields":{"slug":"/ui-testing-handbook/react/en/accessibility-testing/","framework":"react","chapter":"accessibility-testing"}}},{"node":{"frontmatter":{"tocTitle":"Automate","title":"How to automate UI tests with Github Actions","description":"Speed up your workflow and ship higher quality of code"},"fields":{"slug":"/ui-testing-handbook/react/en/automate/","framework":"react","chapter":"automate"}}},{"node":{"frontmatter":{"tocTitle":"Conclusion","title":"Conclusion","description":"Get more done by doing less"},"fields":{"slug":"/ui-testing-handbook/react/en/conclusion/","framework":"react","chapter":"conclusion"}}},{"node":{"frontmatter":{"tocTitle":"Interaction","title":"Testing component interactions","description":"Learn how to simulate user behaviour and run functional checks"},"fields":{"slug":"/ui-testing-handbook/react/en/interaction-testing/","framework":"react","chapter":"interaction-testing"}}},{"node":{"frontmatter":{"tocTitle":"Introduction","title":"Introduction to testing UIs","description":"Latest production-ready techniques for testing UIs"},"fields":{"slug":"/ui-testing-handbook/react/en/introduction/","framework":"react","chapter":"introduction"}}},{"node":{"frontmatter":{"tocTitle":"User flow","title":"Testing user flows","description":"Verify that your UI works end-to-end"},"fields":{"slug":"/ui-testing-handbook/react/en/user-flow-testing/","framework":"react","chapter":"user-flow-testing"}}},{"node":{"frontmatter":{"tocTitle":"Visual","title":"Visual testing in Storybook","description":"Learn how to pinpoint UI bugs automatically"},"fields":{"slug":"/ui-testing-handbook/react/en/visual-testing/","framework":"react","chapter":"visual-testing"}}},{"node":{"frontmatter":{"tocTitle":"Workflow","title":"UI Testing Playbook","description":"A testing workflow that doesn’t slow you down"},"fields":{"slug":"/ui-testing-handbook/react/en/workflow/","framework":"react","chapter":"workflow"}}},{"node":{"frontmatter":{"tocTitle":"Composition","title":"Testing composite components","description":"Prevent minor changes from turning into major regressions"},"fields":{"slug":"/ui-testing-handbook/react/en/composition-testing/","framework":"react","chapter":"composition-testing"}}}]},"translationPages":{"edges":[{"node":{"frontmatter":{"tocTitle":"Accessibility","title":"Accessibility testing with Storybook","description":"Fast feedback with integrated tooling"},"fields":{"slug":"/ui-testing-handbook/react/en/accessibility-testing/","framework":"react","chapter":"accessibility-testing","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Automate","title":"How to automate UI tests with Github Actions","description":"Speed up your workflow and ship higher quality of code"},"fields":{"slug":"/ui-testing-handbook/react/en/automate/","framework":"react","chapter":"automate","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Conclusion","title":"Conclusion","description":"Get more done by doing less"},"fields":{"slug":"/ui-testing-handbook/react/en/conclusion/","framework":"react","chapter":"conclusion","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Interaction","title":"Testing component interactions","description":"Learn how to simulate user behaviour and run functional checks"},"fields":{"slug":"/ui-testing-handbook/react/en/interaction-testing/","framework":"react","chapter":"interaction-testing","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Introduction","title":"Introduction to testing UIs","description":"Latest production-ready techniques for testing UIs"},"fields":{"slug":"/ui-testing-handbook/react/en/introduction/","framework":"react","chapter":"introduction","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"User flow","title":"Testing user flows","description":"Verify that your UI works end-to-end"},"fields":{"slug":"/ui-testing-handbook/react/en/user-flow-testing/","framework":"react","chapter":"user-flow-testing","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Visual","title":"Visual testing in Storybook","description":"Learn how to pinpoint UI bugs automatically"},"fields":{"slug":"/ui-testing-handbook/react/en/visual-testing/","framework":"react","chapter":"visual-testing","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Workflow","title":"UI Testing Playbook","description":"A testing workflow that doesn’t slow you down"},"fields":{"slug":"/ui-testing-handbook/react/en/workflow/","framework":"react","chapter":"workflow","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"접근성","title":"스토리북(Storybook)을 통한 접근성 테스트","description":"통합적인 툴 사용(integrated tooling)으로 빠른 피드백 제공"},"fields":{"slug":"/ui-testing-handbook/react/ko/accessibility-testing/","framework":"react","chapter":"accessibility-testing","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"자동화(Automate)","title":"깃허브(Github) 액션으로 UI 테스트 자동화하기","description":"작업 흐름(workflow)을 더 빠르게 만들고, 더 고품질의 코드를 전달하기"},"fields":{"slug":"/ui-testing-handbook/react/ko/automate/","framework":"react","chapter":"automate","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"구성","title":"구성 테스트","description":"사소한 변경이 커다란 회귀로 변하는 것을 방지하기"},"fields":{"slug":"/ui-testing-handbook/react/ko/composition-testing/","framework":"react","chapter":"composition-testing","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"마무리","title":"마무리","description":"적게 손대고 더 많은 게 해결되도록 하자"},"fields":{"slug":"/ui-testing-handbook/react/ko/conclusion/","framework":"react","chapter":"conclusion","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"상호작용","title":"컴포넌트 상호작용 테스트하기","description":"사용자의 동작을 시뮬레이션하고 기능별 검사를 실행하는 방법 알아보기"},"fields":{"slug":"/ui-testing-handbook/react/ko/interaction-testing/","framework":"react","chapter":"interaction-testing","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"소개","title":"UI 테스트 소개","description":"UI 테스트를 위한 최신 개발 방법"},"fields":{"slug":"/ui-testing-handbook/react/ko/introduction/","framework":"react","chapter":"introduction","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"사용자 플로우(User flow)","title":"사용자 플로우(user flow) 테스트하기","description":"UI가 전체적으로 작동하는지 확인해보세요"},"fields":{"slug":"/ui-testing-handbook/react/ko/user-flow-testing/","framework":"react","chapter":"user-flow-testing","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"시각적 요소 테스트","title":"스토리북(Storybook)의 시각적 요소 테스트","description":"UI 버그를 자동으로 찾아내는 방법 알아보기"},"fields":{"slug":"/ui-testing-handbook/react/ko/visual-testing/","framework":"react","chapter":"visual-testing","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"작업 흐름(Workflow)","title":"UI 테스팅 플레이북","description":"우리를 느리게 하지 않는 테스팅 작업 흐름(workflow)"},"fields":{"slug":"/ui-testing-handbook/react/ko/workflow/","framework":"react","chapter":"workflow","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"Composition","title":"Testing composite components","description":"Prevent minor changes from turning into major regressions"},"fields":{"slug":"/ui-testing-handbook/react/en/composition-testing/","framework":"react","chapter":"composition-testing","language":"en"}}}]}},"pageContext":{"guide":"ui-testing-handbook","slug":"/ui-testing-handbook/react/en/automate/","framework":"react","language":"en","chapter":"automate","pageType":"chapter"}},"staticQueryHashes":["238248339"]}