{"componentChunkName":"component---src-components-screens-chapter-screen-index-js","path":"/ui-testing-handbook/react/en/visual-testing/","result":{"data":{"currentPage":{"html":"<p>It's tough to ship bug-free UIs. In the past, developers used unit and snapshot tests to scan for bugs in blobs of HTML. But those methods don't represent what the user actually sees, so bugs never went away.</p>\n<p>Visual testing catches bugs by capturing and comparing image snapshots in a real browser. It allows you to automate the process of checking if your UI looks right.</p>\n<h2>What are visual bugs?</h2>\n<p>Visual bugs are ubiquitous. Cut-off elements. Incorrect colors or font styles. Broken layouts. And missing error states.</p>\n<p>Every company is now a software company. That means every company is responsible for maintaining a UI. But if youâ€™re like me, you probably noticed that companies never seem to have enough people monitor every part of their UI all the time.</p>\n<p><img src=\"/tutorials/ui-testing-handbook/visual-bugs.gif\" alt=\"\"></p>\n<p>Visual bugs are the unintentional errors in your UIs appearance that make it look untrustworthy. Theyâ€™re the regressions that are easy to eyeball but that common testing methods canâ€™t catch.</p>\n<p>Most tests are intended to verify logic, which makes sense: you run a function, get its output and check whether it's correct or not. Computers are great at verifying data. But what about how something looks?</p>\n<p>Well, there are two layers to this problem.</p>\n<h3>1. Does it look right?</h3>\n<p>Take, for example, this Task component. It looks different depending on what state itâ€™s in. We display a checked (or unchecked) checkbox, some information about the task, and a pin button. And of course, all the associated styling.</p>\n<p><img src=\"/tutorials/ui-testing-handbook/task.gif\" alt=\"Different states of a task component\"></p>\n<p>The first challenge is just to verify the component's appearance in all these scenarios. That requires a lot of fiddling with props &#x26; state to set up and test each case. Oh, and computers canâ€™t really tell you if it matches the spec or not. You, <em>the developer,</em> have to visually inspect it.</p>\n<h3>2. Does it <i>still</i> look right?</h3>\n<p>You built it right the first time. It looks good in <em>all states</em>. But changes happen over the natural course of development. Bugs inevitably sneak in. This is especially true for interfaces. A minor CSS tweak can break a component or one of its states.</p>\n<p>You canâ€™t manually check the breadth of the UI every time you make a change. You need something more automated.</p>\n<h2>Visual testing</h2>\n<p>Visual testing allows you to tackle both these tasks with one unified workflow. It is the process of verifying the appearance of a component as youâ€™re building it. And again as you iterate to ship new features.</p>\n<p>Here's what the visual testing workflow looks like:</p>\n<ol>\n<li>ğŸ· <strong>Isolate</strong> components. Use <a href=\"https://storybook.js.org/\">Storybook</a> to focus on and test one component at a time.</li>\n<li>âœğŸ½ <strong>Write out the test cases.</strong> Each state is reproduced using props and mock data.</li>\n<li>ğŸ” <strong>Manually verify</strong> the appearance of each test case.</li>\n<li>ğŸ“¸ <strong>Catch UI bugs automatically.</strong> Capture snapshots of each test case and use machine-based diffing to check for regressions.</li>\n</ol>\n<p>The crux of visual testing is isolating the UI from the rest of the app (data, backend, APIs). That allows you to observe each state individually. You can then manually spot check and automatically regression test those states.</p>\n<p>Let's go through each step in detail.</p>\n<h3>1. Isolate components</h3>\n<p>Itâ€™s much easier to pinpoint bugs by testing one component at a time and writing a test case for each of its states. The conventional approach is to build the component on the application page where it is first used. Which makes it hard to simulate and verify all these states. Thereâ€™s a better wayâ€”Storybook.</p>\n<p>Storybook is the industry-standard for building components in isolation. Itâ€™s used by Twitter, Slack, Airbnb, Shopify, Stripe, and Microsoft. It is packaged as a small standalone tool that lives alongside your app, giving you:</p>\n<ul>\n<li>ğŸ“¥ A <strong>sandbox</strong> to render each component in isolation</li>\n<li>ğŸ”­ Visualize all its <strong>states</strong> as <em>stories</em></li>\n<li>ğŸ“‘ <strong>Document</strong> props and usage guidelines for each component</li>\n<li>ğŸ—ƒï¸ A <strong>directory</strong> of all your components to make discovery easier</li>\n</ul>\n<p>Letâ€™s go back to that Task component. To isolate it means that we load up and render this one component by itself. For that, we need Storybook.</p>\n<h3>Set up Storybook</h3>\n<p>Our project is preconfigured to use Storybook. The config lives in the <code>.storybook</code> folder and all the necessary scripts have been added to <code>package.json</code>.</p>\n<p>We can start by creating a story file for the Task component. This registers the component with Storybook and adds in one default test case.</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`import Task from './Task';\n\nexport default {\n  component: Task,\n  title: 'Task',\n  argTypes: {\n    onArchiveTask: { action: 'onArchiveTask' },\n    onTogglePinTask: { action: 'onTogglePinTask' },\n    onEditTitle: { action: 'onEditTitle' },\n  },\n};\n\nexport const Default = {\n  args: {\n    task: {\n      id: '1',\n      title: 'Buy milk',\n      state: 'TASK_INBOX',\n    },\n  },\n};`, `37555779246749114000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"37555779246749114000\"\n              >\n                Copy \n              </div>\n            </div>\n<div class=\"gatsby-code-title\">src/components/Task.stories.jsx</div>\n<pre><code class=\"language-javascript\">import Task from './Task';\n\nexport default {\n  component: Task,\n  title: 'Task',\n  argTypes: {\n    onArchiveTask: { action: 'onArchiveTask' },\n    onTogglePinTask: { action: 'onTogglePinTask' },\n    onEditTitle: { action: 'onEditTitle' },\n  },\n};\n\nexport const Default = {\n  args: {\n    task: {\n      id: '1',\n      title: 'Buy milk',\n      state: 'TASK_INBOX',\n    },\n  },\n};\n</code></pre>\n<p>And finally, run the following command to start Storybook in development mode. You should see the Task component load up.</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`yarn storybook`, `16835016914373102000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"16835016914373102000\"\n              >\n                Copy \n              </div>\n            </div>\n<pre><code class=\"language-shell\">yarn storybook\n</code></pre>\n<p><img src=\"/tutorials/ui-testing-handbook/initial-task-state.png\" alt=\"\"></p>\n<p>We're now ready to write out the test cases.</p>\n<h3>2. Write test cases</h3>\n<p>In Storybook, test cases are referred to as stories. A story captures a particular state of the componentâ€”the actual rendered state in the browser.</p>\n<p>The Task component has three statesâ€”default, pinned and archived. Weâ€™ll add a story for each one.</p>\n<p><img src=\"/tutorials/ui-testing-handbook/task-states.png\" alt=\"\"></p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`import Task from './Task';\n\nexport default {\n  component: Task,\n  title: 'Task',\n  argTypes: {\n    onArchiveTask: { action: 'onArchiveTask' },\n    onTogglePinTask: { action: 'onTogglePinTask' },\n    onEditTitle: { action: 'onEditTitle' },\n  },\n};\n\nexport const Default = {\n  args: {\n    task: {\n      id: '1',\n      title: 'Buy milk',\n      state: 'TASK_INBOX',\n    },\n  },\n};\n\nexport const Pinned = {\n  args: {\n    task: {\n      id: '2',\n      title: 'QA dropdown',\n      state: 'TASK_PINNED',\n    },\n  },\n};\n\nexport const Archived = {\n  args: {\n    task: {\n      id: '3',\n      title: 'Write schema for account menu',\n      state: 'TASK_ARCHIVED',\n    },\n  },\n};`, `55903741909656216000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"55903741909656216000\"\n              >\n                Copy \n              </div>\n            </div>\n<div class=\"gatsby-code-title\">src/components/Task.stories.jsx</div>\n<pre><code class=\"language-javascript\">import Task from './Task';\n\nexport default {\n  component: Task,\n  title: 'Task',\n  argTypes: {\n    onArchiveTask: { action: 'onArchiveTask' },\n    onTogglePinTask: { action: 'onTogglePinTask' },\n    onEditTitle: { action: 'onEditTitle' },\n  },\n};\n\nexport const Default = {\n  args: {\n    task: {\n      id: '1',\n      title: 'Buy milk',\n      state: 'TASK_INBOX',\n    },\n  },\n};\n\nexport const Pinned = {\n  args: {\n    task: {\n      id: '2',\n      title: 'QA dropdown',\n      state: 'TASK_PINNED',\n    },\n  },\n};\n\nexport const Archived = {\n  args: {\n    task: {\n      id: '3',\n      title: 'Write schema for account menu',\n      state: 'TASK_ARCHIVED',\n    },\n  },\n};\n</code></pre>\n<h2>3. Verify</h2>\n<p>Verification is <em>you</em> evaluating how the component looks in Storybook. That is, does it match the design spec?</p>\n<p>The usual development workflow is:</p>\n<ol>\n<li>Edit the code</li>\n<li>Get the component in the appropriate state</li>\n<li>Evaluate its appearance</li>\n</ol>\n<p>And then repeat the whole cycle until youâ€™ve verified all its states.</p>\n<p>By writing a story for each state, you cut out that second step. You can go right from editing code to verifying all test cases. Thus, dramatically speeding up the whole process.</p>\n<p>Writing out stories also surfaces scenarios that you wouldn't have considered had you developed it in a more ad-hoc way. For example, what happens if the user enters a really long task? Let's add in that story to find out.</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`const longTitleString = \\`This task's name is absurdly large. In fact, I think if I keep going I might end up with content overflow. What will happen? The star that represents a pinned task could have text overlapping. The text could cut-off abruptly when it reaches the star. I hope not!\\`;\n\nexport const LongTitle = {\n  args: {\n    task: {\n      id: '4',\n      title: longTitleString,\n      state: 'TASK_INBOX',\n    },\n  },\n};`, `5326386245552217000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"5326386245552217000\"\n              >\n                Copy \n              </div>\n            </div>\n<div class=\"gatsby-code-title\">src/components/Task.stories.jsx</div>\n<pre><code class=\"language-javascript\">const longTitleString = `This task's name is absurdly large. In fact, I think if I keep going I might end up with content overflow. What will happen? The star that represents a pinned task could have text overlapping. The text could cut-off abruptly when it reaches the star. I hope not!`;\n\nexport const LongTitle = {\n  args: {\n    task: {\n      id: '4',\n      title: longTitleString,\n      state: 'TASK_INBOX',\n    },\n  },\n};\n</code></pre>\n<p>Now that we've verified the appearance of each test case, we can move on to the next step. Catching regressions automatically. But first, commit your changes.</p>\n<h2>4. Catch regressions automatically</h2>\n<p>The Task component looks as we expect it to in all its use cases. But, how do we ensure that a stray line of CSS doesnâ€™t break it in the future? Itâ€™s unrealistic to <strong>manually</strong> go through the entire directory of components whenever you make a change.</p>\n<p>Thatâ€™s why developers use a visual regression testing tool to automatically check for regressions. Auth0, Twilio, Adobe and Peloton use <a href=\"http://chromatic.com/\">Chromatic</a> (built by the Storybook team).</p>\n<p>At this point, we know that the component is in a good state. Chromatic will capture an image snapshot of every storyâ€”as it appears in the browser. Then any time you make a change, a new snapshot is captured and compared to the previous one. You then review any visual differences found to decide if they are intentional updates or accidental bugs.</p>\n<p><img src=\"/tutorials/ui-testing-handbook/visual-regression-testing.gif\" alt=\"\"></p>\n<h3>Set up Chromatic</h3>\n<p>Sign in and <a href=\"https://www.chromatic.com/docs/setup?utm_source=storybook_website&#x26;utm_medium=link&#x26;utm_campaign=storybook\">create a new project</a> and grab your project-token.</p>\n<p>Chromatic is built specifically for Storybook and requires no configuration. Running the command below will trigger it to capture a snapshot of each story (using a cloud browser).</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`npx chromatic --project-token=<project-token>`, `93629246068165170000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"93629246068165170000\"\n              >\n                Copy \n              </div>\n            </div>\n<pre><code class=\"language-shell\">npx chromatic --project-token=&#x3C;project-token>\n</code></pre>\n<p>The first run will be set as the baseline i.e., the starting point. And each story has its own baseline.</p>\n<p><img src=\"/tutorials/ui-testing-handbook/ui-testing-chromatic-first-build.png\" alt=\"\"></p>\n<h3>Run tests</h3>\n<p>On each commit, new snapshots are captured and compared against existing baselines to detect UI changes. Letâ€™s see that check in action.</p>\n<p>First, make a tweak to the UI. Weâ€™re going to change the pinned icon and the text styling. Update the Task component, then make a commit and rerun Chromatic.</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`import PropTypes from 'prop-types';\nexport default function Task({\n  task: { id, title, state },\n  onArchiveTask,\n  onTogglePinTask,\n  onEditTitle,\n}) {\n  return (\n    <div\n      className={\\`list-item \\${state}\\`}\n      role=&quot;listitem&quot;\n      aria-label={\\`task-\\${id}\\`}\n    >\n      <label\n        htmlFor=&quot;checked&quot;\n        aria-label={\\`archiveTask-\\${id}\\`}\n        className=&quot;checkbox&quot;\n      >\n        <input\n          type=&quot;checkbox&quot;\n          disabled={true}\n          name=&quot;checked&quot;\n          id={\\`archiveTask-\\${id}\\`}\n          checked={state === &quot;TASK_ARCHIVED&quot;}\n        />\n        <span\n          className=&quot;checkbox-custom&quot;\n          onClick={() => onArchiveTask(&quot;ARCHIVE_TASK&quot;, id)}\n          role=&quot;button&quot;\n          aria-label={\\`archiveButton-\\${id}\\`}\n        />\n      </label>\n\n      <label htmlFor=&quot;title&quot; aria-label={title} className=&quot;title&quot;>\n        <input\n          type=&quot;text&quot;\n          value={title}\n          name=&quot;title&quot;\n          placeholder=&quot;Input title&quot;\n          style={{ textOverflow: &quot;ellipsis&quot; }}\n          onChange={(e) => onEditTitle(e.target.value, id)}\n        />\n      </label>\n\n      {state !== &quot;TASK_ARCHIVED&quot; && (\n        <button\n          className=&quot;pin-button&quot;\n          onClick={() => onTogglePinTask(state, id)}\n          id={\\`pinTask-\\${id}\\`}\n          aria-label={state === &quot;TASK_PINNED&quot; ? &quot;unpin&quot; : &quot;pin&quot;}\n          key={\\`pinTask-\\${id}\\`}\n        >\n         <span className={\\`icon-star\\`} />\n        </button>\n      )}\n    </div>\n  );\n}\n\nTask.propTypes = {\n  /** Composition of the task */\n  task: PropTypes.shape({\n    /** Id of the task */\n    id: PropTypes.string.isRequired,\n    /** Title of the task */\n    title: PropTypes.string.isRequired,\n    /** Current state of the task */\n    state: PropTypes.string.isRequired,\n  }),\n  /** Event to change the task to archived */\n  onArchiveTask: PropTypes.func.isRequired,\n  /** Event to change the task to pinned */\n  onTogglePinTask: PropTypes.func.isRequired,\n  /** Event to change the task title */\n  onEditTitle: PropTypes.func.isRequired,\n};`, `26800318366763020000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"26800318366763020000\"\n              >\n                Copy \n              </div>\n            </div>\n<div class=\"gatsby-code-title\">src/components/Task.jsx</div>\n<pre><code class=\"language-diff\">import PropTypes from 'prop-types';\nexport default function Task({\n  task: { id, title, state },\n  onArchiveTask,\n  onTogglePinTask,\n  onEditTitle,\n}) {\n  return (\n    &#x3C;div\n      className={`list-item ${state}`}\n      role=\"listitem\"\n      aria-label={`task-${id}`}\n    >\n      &#x3C;label\n        htmlFor=\"checked\"\n        aria-label={`archiveTask-${id}`}\n        className=\"checkbox\"\n      >\n        &#x3C;input\n          type=\"checkbox\"\n          disabled={true}\n          name=\"checked\"\n          id={`archiveTask-${id}`}\n          checked={state === \"TASK_ARCHIVED\"}\n        />\n        &#x3C;span\n          className=\"checkbox-custom\"\n          onClick={() => onArchiveTask(\"ARCHIVE_TASK\", id)}\n          role=\"button\"\n          aria-label={`archiveButton-${id}`}\n        />\n      &#x3C;/label>\n\n      &#x3C;label htmlFor=\"title\" aria-label={title} className=\"title\">\n        &#x3C;input\n          type=\"text\"\n          value={title}\n          name=\"title\"\n          placeholder=\"Input title\"\n          style={{ textOverflow: \"ellipsis\" }}\n          onChange={(e) => onEditTitle(e.target.value, id)}\n        />\n      &#x3C;/label>\n\n      {state !== \"TASK_ARCHIVED\" &#x26;&#x26; (\n        &#x3C;button\n          className=\"pin-button\"\n          onClick={() => onTogglePinTask(state, id)}\n          id={`pinTask-${id}`}\n          aria-label={state === \"TASK_PINNED\" ? \"unpin\" : \"pin\"}\n          key={`pinTask-${id}`}\n        >\n+         &#x3C;span className={`icon-star`} />\n        &#x3C;/button>\n      )}\n    &#x3C;/div>\n  );\n}\n\nTask.propTypes = {\n  /** Composition of the task */\n  task: PropTypes.shape({\n    /** Id of the task */\n    id: PropTypes.string.isRequired,\n    /** Title of the task */\n    title: PropTypes.string.isRequired,\n    /** Current state of the task */\n    state: PropTypes.string.isRequired,\n  }),\n  /** Event to change the task to archived */\n  onArchiveTask: PropTypes.func.isRequired,\n  /** Event to change the task to pinned */\n  onTogglePinTask: PropTypes.func.isRequired,\n  /** Event to change the task title */\n  onEditTitle: PropTypes.func.isRequired,\n};\n</code></pre>\n<p>Youâ€™ll now be presented with a diff.</p>\n<video autoPlay muted playsInline loop>\n  <source\n    src=\"/tutorials/ui-testing-handbook/chromatic-task-diff.mp4\"\n    type=\"video/mp4\"\n  />\n</video>\n<p>Regression testing ensures that we donâ€™t introduce changes by accident. But itâ€™s still up to you to decide whether changes are intentional or not.</p>\n<p>âœ… If the changes are intentional, press accept. The new snapshot will now be set as the baseline.</p>\n<p>âŒ If the changes are unintentional, press deny. The build will fail. Fix the code and run Chromatic again.</p>\n<p>In our case, the changes were intentional. Go ahead and click accept for all stories. The whole workflow is illustrated below.</p>\n<p><img src=\"/tutorials/ui-testing-handbook/visual-testing-workflow.png\" alt=\"Build in storybook and run visual tests with Chromatic. If changes look good, then merge your PR.\"></p>\n<h2>Stopping one bug from turning into many</h2>\n<p>A bit of leaky CSS or one broken component can snowball into multiple issues. These bugs are particularly frustrating to debug. In the next chapter, we'll build upon these concepts to learn how to catch such cascading problems.</p>","frontmatter":{"title":"Visual testing in Storybook","description":"Learn how to pinpoint UI bugs automatically","commit":"576a94f"},"fields":{"guide":"ui-testing-handbook","slug":"/ui-testing-handbook/react/en/visual-testing/","chapter":"visual-testing","framework":"react","language":"en","permalink":"https://storybook.js.org/tutorials/ui-testing-handbook/react/en/visual-testing/","tutorialUpToDate":true}},"currentGuide":{"frontmatter":{"codeGithubUrl":"https://github.com/chromaui/ui-testing-guide-code","toc":["introduction","visual-testing","composition-testing","interaction-testing","accessibility-testing","user-flow-testing","automate","workflow","conclusion"],"title":"UI Testing Handbook","twitterShareText":"I'm learning how to test UIs! This will help me ship UIs without worrying about stowaway bugs."}},"site":{"siteMetadata":{"title":"Storybook Tutorials","githubUrl":"https://github.com/chromaui/learnstorybook.com","contributeUrl":"https://github.com/chromaui/learnstorybook.com/#contribute","permalink":"https://storybook.js.org/tutorials","siteUrl":"https://storybook.js.org"}},"tocPages":{"edges":[{"node":{"frontmatter":{"tocTitle":"Accessibility","title":"Accessibility testing with Storybook","description":"Fast feedback with integrated tooling"},"fields":{"slug":"/ui-testing-handbook/react/en/accessibility-testing/","framework":"react","chapter":"accessibility-testing"}}},{"node":{"frontmatter":{"tocTitle":"Automate","title":"How to automate UI tests with Github Actions","description":"Speed up your workflow and ship higher quality of code"},"fields":{"slug":"/ui-testing-handbook/react/en/automate/","framework":"react","chapter":"automate"}}},{"node":{"frontmatter":{"tocTitle":"Conclusion","title":"Conclusion","description":"Get more done by doing less"},"fields":{"slug":"/ui-testing-handbook/react/en/conclusion/","framework":"react","chapter":"conclusion"}}},{"node":{"frontmatter":{"tocTitle":"Interaction","title":"Testing component interactions","description":"Learn how to simulate user behaviour and run functional checks"},"fields":{"slug":"/ui-testing-handbook/react/en/interaction-testing/","framework":"react","chapter":"interaction-testing"}}},{"node":{"frontmatter":{"tocTitle":"Introduction","title":"Introduction to testing UIs","description":"Latest production-ready techniques for testing UIs"},"fields":{"slug":"/ui-testing-handbook/react/en/introduction/","framework":"react","chapter":"introduction"}}},{"node":{"frontmatter":{"tocTitle":"User flow","title":"Testing user flows","description":"Verify that your UI works end-to-end"},"fields":{"slug":"/ui-testing-handbook/react/en/user-flow-testing/","framework":"react","chapter":"user-flow-testing"}}},{"node":{"frontmatter":{"tocTitle":"Visual","title":"Visual testing in Storybook","description":"Learn how to pinpoint UI bugs automatically"},"fields":{"slug":"/ui-testing-handbook/react/en/visual-testing/","framework":"react","chapter":"visual-testing"}}},{"node":{"frontmatter":{"tocTitle":"Workflow","title":"UI Testing Playbook","description":"A testing workflow that doesnâ€™t slow you down"},"fields":{"slug":"/ui-testing-handbook/react/en/workflow/","framework":"react","chapter":"workflow"}}},{"node":{"frontmatter":{"tocTitle":"Composition","title":"Testing composite components","description":"Prevent minor changes from turning into major regressions"},"fields":{"slug":"/ui-testing-handbook/react/en/composition-testing/","framework":"react","chapter":"composition-testing"}}}]},"translationPages":{"edges":[{"node":{"frontmatter":{"tocTitle":"Accessibility","title":"Accessibility testing with Storybook","description":"Fast feedback with integrated tooling"},"fields":{"slug":"/ui-testing-handbook/react/en/accessibility-testing/","framework":"react","chapter":"accessibility-testing","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Automate","title":"How to automate UI tests with Github Actions","description":"Speed up your workflow and ship higher quality of code"},"fields":{"slug":"/ui-testing-handbook/react/en/automate/","framework":"react","chapter":"automate","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Conclusion","title":"Conclusion","description":"Get more done by doing less"},"fields":{"slug":"/ui-testing-handbook/react/en/conclusion/","framework":"react","chapter":"conclusion","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Interaction","title":"Testing component interactions","description":"Learn how to simulate user behaviour and run functional checks"},"fields":{"slug":"/ui-testing-handbook/react/en/interaction-testing/","framework":"react","chapter":"interaction-testing","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Introduction","title":"Introduction to testing UIs","description":"Latest production-ready techniques for testing UIs"},"fields":{"slug":"/ui-testing-handbook/react/en/introduction/","framework":"react","chapter":"introduction","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"User flow","title":"Testing user flows","description":"Verify that your UI works end-to-end"},"fields":{"slug":"/ui-testing-handbook/react/en/user-flow-testing/","framework":"react","chapter":"user-flow-testing","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Visual","title":"Visual testing in Storybook","description":"Learn how to pinpoint UI bugs automatically"},"fields":{"slug":"/ui-testing-handbook/react/en/visual-testing/","framework":"react","chapter":"visual-testing","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Workflow","title":"UI Testing Playbook","description":"A testing workflow that doesnâ€™t slow you down"},"fields":{"slug":"/ui-testing-handbook/react/en/workflow/","framework":"react","chapter":"workflow","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"ì ‘ê·¼ì„±","title":"ìŠ¤í† ë¦¬ë¶(Storybook)ì„ í†µí•œ ì ‘ê·¼ì„± í…ŒìŠ¤íŠ¸","description":"í†µí•©ì ì¸ íˆ´ ì‚¬ìš©(integrated tooling)ìœ¼ë¡œ ë¹ ë¥¸ í”¼ë“œë°± ì œê³µ"},"fields":{"slug":"/ui-testing-handbook/react/ko/accessibility-testing/","framework":"react","chapter":"accessibility-testing","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"ìë™í™”(Automate)","title":"ê¹ƒí—ˆë¸Œ(Github) ì•¡ì…˜ìœ¼ë¡œ UI í…ŒìŠ¤íŠ¸ ìë™í™”í•˜ê¸°","description":"ì‘ì—… íë¦„(workflow)ì„ ë” ë¹ ë¥´ê²Œ ë§Œë“¤ê³ , ë” ê³ í’ˆì§ˆì˜ ì½”ë“œë¥¼ ì „ë‹¬í•˜ê¸°"},"fields":{"slug":"/ui-testing-handbook/react/ko/automate/","framework":"react","chapter":"automate","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"êµ¬ì„±","title":"êµ¬ì„± í…ŒìŠ¤íŠ¸","description":"ì‚¬ì†Œí•œ ë³€ê²½ì´ ì»¤ë‹¤ë€ íšŒê·€ë¡œ ë³€í•˜ëŠ” ê²ƒì„ ë°©ì§€í•˜ê¸°"},"fields":{"slug":"/ui-testing-handbook/react/ko/composition-testing/","framework":"react","chapter":"composition-testing","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"ë§ˆë¬´ë¦¬","title":"ë§ˆë¬´ë¦¬","description":"ì ê²Œ ì†ëŒ€ê³  ë” ë§ì€ ê²Œ í•´ê²°ë˜ë„ë¡ í•˜ì"},"fields":{"slug":"/ui-testing-handbook/react/ko/conclusion/","framework":"react","chapter":"conclusion","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"ìƒí˜¸ì‘ìš©","title":"ì»´í¬ë„ŒíŠ¸ ìƒí˜¸ì‘ìš© í…ŒìŠ¤íŠ¸í•˜ê¸°","description":"ì‚¬ìš©ìì˜ ë™ì‘ì„ ì‹œë®¬ë ˆì´ì…˜í•˜ê³  ê¸°ëŠ¥ë³„ ê²€ì‚¬ë¥¼ ì‹¤í–‰í•˜ëŠ” ë°©ë²• ì•Œì•„ë³´ê¸°"},"fields":{"slug":"/ui-testing-handbook/react/ko/interaction-testing/","framework":"react","chapter":"interaction-testing","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"ì†Œê°œ","title":"UI í…ŒìŠ¤íŠ¸ ì†Œê°œ","description":"UI í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•œ ìµœì‹  ê°œë°œ ë°©ë²•"},"fields":{"slug":"/ui-testing-handbook/react/ko/introduction/","framework":"react","chapter":"introduction","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"ì‚¬ìš©ì í”Œë¡œìš°(User flow)","title":"ì‚¬ìš©ì í”Œë¡œìš°(user flow) í…ŒìŠ¤íŠ¸í•˜ê¸°","description":"UIê°€ ì „ì²´ì ìœ¼ë¡œ ì‘ë™í•˜ëŠ”ì§€ í™•ì¸í•´ë³´ì„¸ìš”"},"fields":{"slug":"/ui-testing-handbook/react/ko/user-flow-testing/","framework":"react","chapter":"user-flow-testing","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"ì‹œê°ì  ìš”ì†Œ í…ŒìŠ¤íŠ¸","title":"ìŠ¤í† ë¦¬ë¶(Storybook)ì˜ ì‹œê°ì  ìš”ì†Œ í…ŒìŠ¤íŠ¸","description":"UI ë²„ê·¸ë¥¼ ìë™ìœ¼ë¡œ ì°¾ì•„ë‚´ëŠ” ë°©ë²• ì•Œì•„ë³´ê¸°"},"fields":{"slug":"/ui-testing-handbook/react/ko/visual-testing/","framework":"react","chapter":"visual-testing","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"ì‘ì—… íë¦„(Workflow)","title":"UI í…ŒìŠ¤íŒ… í”Œë ˆì´ë¶","description":"ìš°ë¦¬ë¥¼ ëŠë¦¬ê²Œ í•˜ì§€ ì•ŠëŠ” í…ŒìŠ¤íŒ… ì‘ì—… íë¦„(workflow)"},"fields":{"slug":"/ui-testing-handbook/react/ko/workflow/","framework":"react","chapter":"workflow","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"Composition","title":"Testing composite components","description":"Prevent minor changes from turning into major regressions"},"fields":{"slug":"/ui-testing-handbook/react/en/composition-testing/","framework":"react","chapter":"composition-testing","language":"en"}}}]}},"pageContext":{"guide":"ui-testing-handbook","slug":"/ui-testing-handbook/react/en/visual-testing/","framework":"react","language":"en","chapter":"visual-testing","pageType":"chapter"}},"staticQueryHashes":["238248339"]}