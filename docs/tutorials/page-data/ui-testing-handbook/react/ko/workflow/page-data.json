{"componentChunkName":"component---src-components-screens-chapter-screen-index-js","path":"/ui-testing-handbook/react/ko/workflow/","result":{"data":{"currentPage":{"html":"<p>UI의 서로 다른 부분을 테스트 하는 도구를 찾기는 쉽습니다. 하지만 이 모든 걸 생산적인 작업 흐름으로 어떻게 결합하는 방법을 깨닫기는 쉽지 않습니다. 잘못 이해하면, 유지보수의 악몽에 빠질 수도 있습니다.</p>\n<p>우리의 작업 흐름(workflow)은 스토리(story)를 테스트 케이스로 재사용해서 유지보수 부담을 줄여줍니다. 또한 컴포넌트 수준에서 테스트해서 버그를 빨리 발견할 수 있습니다.</p>\n<p>이 장에서는 할일을 삭제하는 기능을 추가하면서 UI testing 작업 흐름의 전체를 보여줍니다.</p>\n<p><img src=\"/tutorials/ui-testing-handbook/workflow-ui-testing.png\" alt=\"\"></p>\n<h2>빌드(build)</h2>\n<p>이 Task 컴포넌트는 이미 사용자가 할일을 수정할 수 있고, 고정할 수 있고, 보관할 수 있습니다. 이제 삭제 버튼을 추가하고, 이 버튼을 애플리케이션 상태에 연결해서 삭제 기능을 추가해보겠습니다.</p>\n<p><img src=\"/tutorials/ui-testing-handbook/add-delete-button.png\" alt=\"\"></p>\n<p>이 데모를 위해서, 테스트할 준비가 된 지점으로 곧장 건너뛰어봅시다. 업데이트된 파일들을 다운 받고, <code>/src</code> 디렉토리에 놓아주세요 -</p>\n<ul>\n<li><a href=\"https://raw.githubusercontent.com/chromaui/ui-testing-guide-code/910607eb1d6c9a593c9577ad6eb0e074a9b762d8/src/components/Task.jsx\">src/components/Task.jsx</a></li>\n<li><a href=\"https://raw.githubusercontent.com/chromaui/ui-testing-guide-code/910607eb1d6c9a593c9577ad6eb0e074a9b762d8/src/components/TaskList.jsx\">src/components/TaskList.jsx</a></li>\n<li><a href=\"https://raw.githubusercontent.com/chromaui/ui-testing-guide-code/910607eb1d6c9a593c9577ad6eb0e074a9b762d8/src/InboxScreen.jsx\">src/InboxScreen.jsx</a></li>\n</ul>\n<h3>시각적 요소와 구성 테스트</h3>\n<p>먼저, 수정된 UI의 스타일이 명세(spec)와 일치한다는 걸 보장해야 합니다. Task 컴포넌트는 이제 삭제를 다루기 위해 <code>onDeleteTask</code> prop이 필요합니다. 일단 이를 Task story에서 모의해줍니다.</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`import React from 'react';\nimport { Task } from './Task';\nexport default {\n  component: Task,\n  title: 'Task',\n  argTypes: {\n    onArchiveTask: { action: 'onArchiveTask' },\n    onTogglePinTask: { action: 'onTogglePinTask' },\n    onEditTitle: { action: 'onEditTitle' },\n   onDeleteTask: { action: 'onDeleteTask' },\n  },\n  parameters: {\n    a11y: {\n ...`, `72482975222241165000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"72482975222241165000\"\n              >\n                Copy \n              </div>\n            </div>\n<div class=\"gatsby-code-title\">src/components/Task.stories.js</div>\n<pre><code class=\"language-diff\">import React from 'react';\nimport { Task } from './Task';\nexport default {\n  component: Task,\n  title: 'Task',\n  argTypes: {\n    onArchiveTask: { action: 'onArchiveTask' },\n    onTogglePinTask: { action: 'onTogglePinTask' },\n    onEditTitle: { action: 'onEditTitle' },\n+   onDeleteTask: { action: 'onDeleteTask' },\n  },\n  parameters: {\n    a11y: {\n ...\n</code></pre>\n<h4>개발하는 동안</h4>\n<p>앱 전체를 실행하는 대신에, 스토리북(Storybook)을 이용해서 오직 Task 컴포넌트에만 집중할 수 있습니다. 그 뒤에는 모든 스토리를 돌면서, 수동으로 직접 컴포넌트의 모양을 검증할 수 있습니다.</p>\n<p><img src=\"/tutorials/ui-testing-handbook/task-stories.gif\" alt=\"\"></p>\n<h4>PR 확인</h4>\n<p>Task UI를 약간 고쳤을 때, 이를 사용하는 다른 컴포넌트를 의도치 않게 변경해버릴 수도 있습니다. TaskList나 InboxScreen처럼요. 크로마틱(Chromatic)으로 시각적 요소 테스트를 실행하면 이를 잡아낼 겁니다. 이를 통해 모든 게 정확하게 연결되어 있다는 걸 보장해주기도 합니다.</p>\n<p>크로마틱은 풀 리퀘스트(pull request)를 만들면 자동으로 작동할 겁니다. 완료되고 나면 리뷰할 변경 사항을 보게 될 겁니다. 이 경우에는 일부러 UI를 변경했습니다. accept 버튼을 눌러서 기준점을 최신으로 업데이트해줍니다.</p>\n<p><img src=\"/tutorials/ui-testing-handbook/workflow-visual-tests.png\" alt=\"\"></p>\n<p><img src=\"/tutorials/ui-testing-handbook/workflow-visual-diff.png\" alt=\"\"></p>\n<h3>접근성 테스트</h3>\n<p><img src=\"/tutorials/ui-testing-handbook/task-a11y.gif\" alt=\"\"></p>\n<h4>개발하는 동안</h4>\n<p>개발하는 동안 스토리북에서 접근성 검사를 실행해보세요. <a href=\"https://storybook.js.org/addons/@storybook/addon-a11y\">A11y 애드온</a>은 Axe를 사용해서 활성화된 스토리의 변경을 추적(audit)하고 애드온 패널에 리포트를 보여줍니다. 한 번 빠르게 훑어보기만 해도 우리의 스토리가 모두 위반사항이 없다는 걸 확인할 수 있습니다.</p>\n<h4>PR 확인</h4>\n<p>회귀 오류를 잡아내기 위해서는 모든 컴포넌트를 검사해야 합니다. 스토리를 test file에 모두 import하고 <a href=\"https://github.com/twilio-labs/paste/blob/cd0ddad508e41cb9982a693a5160f1b7866f4e2a/packages/paste-core/components/checkbox/__tests__/checkboxdisclaimer.test.tsx#L40\">jest-axe</a>를 이용해서 접근성 추적을 실행해주면 됩니다. 모든 위반사항은 PR 페이지로 보고될 것입니다.</p>\n<p><img src=\"/tutorials/ui-testing-handbook/ci-a11y.png\" alt=\"\"></p>\n<h3>상호작용 테스트</h3>\n<p>사용자는 <em>쓰레기통</em> 버튼을 클릭해서, 할일을 삭제할 수 있고, 이 동작을 검증하기 위해서 테스트에 추가해야 합니다.</p>\n<p><img src=\"/tutorials/ui-testing-handbook/manual-interaction.gif\" alt=\"\"></p>\n<h4>개발하는 동안</h4>\n<p>개발 중에는, InboxScreen story를 이용해서 수동으로 상호작용을 검증합니다. 기대한대로 동작한다면, 재생 기능을 이용해 상호 작용 테스트를 추가할 수 있습니다.</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`// ... code omitted for brevity ...\n\nexport const DeleteTask = Template.bind({});\nDeleteTask.parameters = { ...Default.parameters };\nDeleteTask.play = async ({ canvasElement }) => {\n  const canvas = within(canvasElement);\n  const getTask = (name) => canvas.findByRole('listitem', { name });\n\n  const itemToDelete = await getTask('Build a date picker');\n  const deleteButton = await findByRole(itemToDelete, 'button', {\n    name: 'delete',\n  });\n  await userEvent.click(deleteButton);\n\n  await expect(canvas.getAllByRole('listitem').length).toBe(5);\n};`, `16467943489822212000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"16467943489822212000\"\n              >\n                Copy \n              </div>\n            </div>\n<div class=\"gatsby-code-title\">src/InboxScreen.stories.js</div>\n<pre><code class=\"language-javascript\">// ... code omitted for brevity ...\n\nexport const DeleteTask = Template.bind({});\nDeleteTask.parameters = { ...Default.parameters };\nDeleteTask.play = async ({ canvasElement }) => {\n  const canvas = within(canvasElement);\n  const getTask = (name) => canvas.findByRole('listitem', { name });\n\n  const itemToDelete = await getTask('Build a date picker');\n  const deleteButton = await findByRole(itemToDelete, 'button', {\n    name: 'delete',\n  });\n  await userEvent.click(deleteButton);\n\n  await expect(canvas.getAllByRole('listitem').length).toBe(5);\n};\n</code></pre>\n<p><code>yarn run test-storybook</code>를 실행해서 모든 테스트가 통과하는지 확인합니다. Jest가 어떻게 watch 모드에서 실행되며 변경된 파일과 관련된 테스트만 실행하는지 살펴보세요.</p>\n<p><img src=\"/tutorials/ui-testing-handbook/test-runner-delete.png\" alt=\"\"></p>\n<h4>PR 확인</h4>\n<p>PR이 만들어지면 Github Action은 테스트 러너를 실행하고 PR 확인를 통해서 현재의 상태를 보고합니다.</p>\n<p><img src=\"/tutorials/ui-testing-handbook/test-runner-ci.png\" alt=\"\"></p>\n<h2>사용자 흐름 테스트</h2>\n<p>마지막으로, E2E(End-to-end)테스트를 실행해서 모든 결정적인 사용자 흐름이 기대한대로 동작하는지 보장해야 합니다.</p>\n<h4>개발하는 동안</h4>\n<p>저희가 만든 새 기능은 인증 흐름(auth flow)에는 영향을 주지 않습니다. 그래서 CI서버에서 Cypress가 실행될 때까지 기다리면 됩니다. 테스트를 추가하거나 수정했을 때에만 원하는 E2E 테스트를 실행하면 됩니다.</p>\n<p><img src=\"/tutorials/ui-testing-handbook/auth-flow.png\" alt=\"\"></p>\n<h4>PR 확인</h4>\n<p>다른 모든 테스트처럼, Github Actions는 Cypress를 이용해서 E2E도 실행해줍니다.</p>\n<p><img src=\"/tutorials/ui-testing-handbook/user-flow-ci.png\" alt=\"\"></p>\n<h2>모험은 시작되었습니다</h2>\n<p><strong>UI 테스팅 핸드북</strong>은 프로 프런트엔드 팀이 사용하는 테스트 전략을 강조합니다. 이 테스트들은 앱의 health checks처럼 돌아가고, 눈에 보이는 겉모습부터 UI 로직을 검증할 뿐만 아니라, 심지어 통합 이슈까지 감지합니다. 게다가, 지속적 통합으로 매 commit을 자동으로 테스트하면 버그를 감소시킬 수 있습니다.</p>\n<p>마지막 장에서는 완전한 샘플 코드, 도움이 되는 자료들, 개발자들이 자주 하는 질문으로 마무리를 짓겠습니다.</p>","frontmatter":{"title":"UI 테스팅 플레이북","description":"우리를 느리게 하지 않는 테스팅 작업 흐름(workflow)","commit":"910607e"},"fields":{"guide":"ui-testing-handbook","slug":"/ui-testing-handbook/react/ko/workflow/","chapter":"workflow","framework":"react","language":"ko","permalink":"https://storybook.js.org/tutorials/ui-testing-handbook/react/ko/workflow/","tutorialUpToDate":false}},"currentGuide":{"frontmatter":{"codeGithubUrl":"https://github.com/chromaui/ui-testing-guide-code","toc":["introduction","visual-testing","composition-testing","interaction-testing","accessibility-testing","user-flow-testing","automate","workflow","conclusion"],"title":"UI Testing Handbook","twitterShareText":"I'm learning how to test UIs! This will help me ship UIs without worrying about stowaway bugs."}},"site":{"siteMetadata":{"title":"Storybook Tutorials","githubUrl":"https://github.com/chromaui/learnstorybook.com","contributeUrl":"https://github.com/chromaui/learnstorybook.com/#contribute","permalink":"https://storybook.js.org/tutorials","siteUrl":"https://storybook.js.org"}},"tocPages":{"edges":[{"node":{"frontmatter":{"tocTitle":"접근성","title":"스토리북(Storybook)을 통한 접근성 테스트","description":"통합적인 툴 사용(integrated tooling)으로 빠른 피드백 제공"},"fields":{"slug":"/ui-testing-handbook/react/ko/accessibility-testing/","framework":"react","chapter":"accessibility-testing"}}},{"node":{"frontmatter":{"tocTitle":"자동화(Automate)","title":"깃허브(Github) 액션으로 UI 테스트 자동화하기","description":"작업 흐름(workflow)을 더 빠르게 만들고, 더 고품질의 코드를 전달하기"},"fields":{"slug":"/ui-testing-handbook/react/ko/automate/","framework":"react","chapter":"automate"}}},{"node":{"frontmatter":{"tocTitle":"구성","title":"구성 테스트","description":"사소한 변경이 커다란 회귀로 변하는 것을 방지하기"},"fields":{"slug":"/ui-testing-handbook/react/ko/composition-testing/","framework":"react","chapter":"composition-testing"}}},{"node":{"frontmatter":{"tocTitle":"마무리","title":"마무리","description":"적게 손대고 더 많은 게 해결되도록 하자"},"fields":{"slug":"/ui-testing-handbook/react/ko/conclusion/","framework":"react","chapter":"conclusion"}}},{"node":{"frontmatter":{"tocTitle":"상호작용","title":"컴포넌트 상호작용 테스트하기","description":"사용자의 동작을 시뮬레이션하고 기능별 검사를 실행하는 방법 알아보기"},"fields":{"slug":"/ui-testing-handbook/react/ko/interaction-testing/","framework":"react","chapter":"interaction-testing"}}},{"node":{"frontmatter":{"tocTitle":"소개","title":"UI 테스트 소개","description":"UI 테스트를 위한 최신 개발 방법"},"fields":{"slug":"/ui-testing-handbook/react/ko/introduction/","framework":"react","chapter":"introduction"}}},{"node":{"frontmatter":{"tocTitle":"사용자 플로우(User flow)","title":"사용자 플로우(user flow) 테스트하기","description":"UI가 전체적으로 작동하는지 확인해보세요"},"fields":{"slug":"/ui-testing-handbook/react/ko/user-flow-testing/","framework":"react","chapter":"user-flow-testing"}}},{"node":{"frontmatter":{"tocTitle":"시각적 요소 테스트","title":"스토리북(Storybook)의 시각적 요소 테스트","description":"UI 버그를 자동으로 찾아내는 방법 알아보기"},"fields":{"slug":"/ui-testing-handbook/react/ko/visual-testing/","framework":"react","chapter":"visual-testing"}}},{"node":{"frontmatter":{"tocTitle":"작업 흐름(Workflow)","title":"UI 테스팅 플레이북","description":"우리를 느리게 하지 않는 테스팅 작업 흐름(workflow)"},"fields":{"slug":"/ui-testing-handbook/react/ko/workflow/","framework":"react","chapter":"workflow"}}}]},"translationPages":{"edges":[{"node":{"frontmatter":{"tocTitle":"Accessibility","title":"Accessibility testing with Storybook","description":"Fast feedback with integrated tooling"},"fields":{"slug":"/ui-testing-handbook/react/en/accessibility-testing/","framework":"react","chapter":"accessibility-testing","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Automate","title":"How to automate UI tests with Github Actions","description":"Speed up your workflow and ship higher quality of code"},"fields":{"slug":"/ui-testing-handbook/react/en/automate/","framework":"react","chapter":"automate","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Conclusion","title":"Conclusion","description":"Get more done by doing less"},"fields":{"slug":"/ui-testing-handbook/react/en/conclusion/","framework":"react","chapter":"conclusion","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Interaction","title":"Testing component interactions","description":"Learn how to simulate user behaviour and run functional checks"},"fields":{"slug":"/ui-testing-handbook/react/en/interaction-testing/","framework":"react","chapter":"interaction-testing","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Introduction","title":"Introduction to testing UIs","description":"Latest production-ready techniques for testing UIs"},"fields":{"slug":"/ui-testing-handbook/react/en/introduction/","framework":"react","chapter":"introduction","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"User flow","title":"Testing user flows","description":"Verify that your UI works end-to-end"},"fields":{"slug":"/ui-testing-handbook/react/en/user-flow-testing/","framework":"react","chapter":"user-flow-testing","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Visual","title":"Visual testing in Storybook","description":"Learn how to pinpoint UI bugs automatically"},"fields":{"slug":"/ui-testing-handbook/react/en/visual-testing/","framework":"react","chapter":"visual-testing","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Workflow","title":"UI Testing Playbook","description":"A testing workflow that doesn’t slow you down"},"fields":{"slug":"/ui-testing-handbook/react/en/workflow/","framework":"react","chapter":"workflow","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"접근성","title":"스토리북(Storybook)을 통한 접근성 테스트","description":"통합적인 툴 사용(integrated tooling)으로 빠른 피드백 제공"},"fields":{"slug":"/ui-testing-handbook/react/ko/accessibility-testing/","framework":"react","chapter":"accessibility-testing","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"자동화(Automate)","title":"깃허브(Github) 액션으로 UI 테스트 자동화하기","description":"작업 흐름(workflow)을 더 빠르게 만들고, 더 고품질의 코드를 전달하기"},"fields":{"slug":"/ui-testing-handbook/react/ko/automate/","framework":"react","chapter":"automate","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"구성","title":"구성 테스트","description":"사소한 변경이 커다란 회귀로 변하는 것을 방지하기"},"fields":{"slug":"/ui-testing-handbook/react/ko/composition-testing/","framework":"react","chapter":"composition-testing","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"마무리","title":"마무리","description":"적게 손대고 더 많은 게 해결되도록 하자"},"fields":{"slug":"/ui-testing-handbook/react/ko/conclusion/","framework":"react","chapter":"conclusion","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"상호작용","title":"컴포넌트 상호작용 테스트하기","description":"사용자의 동작을 시뮬레이션하고 기능별 검사를 실행하는 방법 알아보기"},"fields":{"slug":"/ui-testing-handbook/react/ko/interaction-testing/","framework":"react","chapter":"interaction-testing","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"소개","title":"UI 테스트 소개","description":"UI 테스트를 위한 최신 개발 방법"},"fields":{"slug":"/ui-testing-handbook/react/ko/introduction/","framework":"react","chapter":"introduction","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"사용자 플로우(User flow)","title":"사용자 플로우(user flow) 테스트하기","description":"UI가 전체적으로 작동하는지 확인해보세요"},"fields":{"slug":"/ui-testing-handbook/react/ko/user-flow-testing/","framework":"react","chapter":"user-flow-testing","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"시각적 요소 테스트","title":"스토리북(Storybook)의 시각적 요소 테스트","description":"UI 버그를 자동으로 찾아내는 방법 알아보기"},"fields":{"slug":"/ui-testing-handbook/react/ko/visual-testing/","framework":"react","chapter":"visual-testing","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"작업 흐름(Workflow)","title":"UI 테스팅 플레이북","description":"우리를 느리게 하지 않는 테스팅 작업 흐름(workflow)"},"fields":{"slug":"/ui-testing-handbook/react/ko/workflow/","framework":"react","chapter":"workflow","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"Composition","title":"Testing composite components","description":"Prevent minor changes from turning into major regressions"},"fields":{"slug":"/ui-testing-handbook/react/en/composition-testing/","framework":"react","chapter":"composition-testing","language":"en"}}}]}},"pageContext":{"guide":"ui-testing-handbook","slug":"/ui-testing-handbook/react/ko/workflow/","framework":"react","language":"ko","chapter":"workflow","pageType":"chapter"}},"staticQueryHashes":["238248339"]}