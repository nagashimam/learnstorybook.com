{"componentChunkName":"component---src-components-screens-chapter-screen-index-js","path":"/ui-testing-handbook/react/ko/accessibility-testing/","result":{"data":{"currentPage":{"html":"<p>미국에 있는 <a href=\"https://www.cdc.gov/ncbddd/disabilityandhealth/infographic-disability-impacts-all.html\">성인의 26%</a>는 적어도 하나의 장애를 가지고 있습니다. 접근성을 개선하면, 현재 그리고 미래의 고객들에게 아주 커다란 영향을 미칩니다. 또한 접근성은 법적 요구 사항이기도 합니다.</p>\n<p>접근성을 확인하는 가장 정확한 방법은 실제 장치에서 수동으로 확인하는 것입니다. 하지만 그러기 위해서는 전문 지식과 많은 시간이 필요한데, 두 가지 모두 프런트엔드 팀에게는 아주 드물게 존재합니다.</p>\n<p>그것이 바로 현재 많은 회사들이 자동과 수동 테스팅을 함께 사용하는 이유입니다. 자동화는 개발자들이 크게 공들이지 않아도 일반적인 접근성 문제를 파악합니다. 수동 QA는 사람의 주의가 필요한 까다로운 문제들을 다룰 때에 사용합니다.</p>\n<p>접근성 원칙에 깊게 파고드는 많은 자료들이 있으므로 여기서는 깊게 다루지 않을 것입니다. 대신에, 스토리북(Storybook)을 통해 접근성 테스트를 자동화하는 방법을 중점적으로 살펴보겠습니다. 이것은 직면하기 쉬운 대부분의 문제들을 찾고 고치는 실용적인 접근법입니다.</p>\n<h2>왜 자동화일까요?</h2>\n<p>시작하기 전에, 일반적인 장애의 유형을 살펴봅시다. - 시각, 청각, 이동성, 인지, 발화 그리고 신경학적인 장애들. 이러한 사용자 장애들로 인해 다음과 같은 앱 요구사항들이 발생합니다 -</p>\n<ul>\n<li>⌨ 키보드 네비게이션</li>\n<li>🗣 스크린 리더기 지원</li>\n<li>👆 터치 친화성</li>\n<li>🎨 충분히 높은 색 대비</li>\n<li>⚡️ 모션 감소</li>\n<li>🔍 확대</li>\n</ul>\n<p>과거에는 브라우저, 장치 및 스크린 리더기의 조합에서 모든 컴포넌트를 검사하여 이러한 각 요구사항을 확인했습니다. 그러나 앱은 수십개의 컴포넌트를 갖고 있고 UI를 지속적으로 업데이트하고 있기 때문에 수작업으로 검사하는 것은 현실적으로 불가능합니다.</p>\n<h2>작업 흐름(workflow)의 속도를 높여주는 자동화</h2>\n<p>자동화된 도구는 <a href=\"https://www.w3.org/WAI/standards-guidelines/wcag/\">WCAG</a> 규칙 및 업계에서 입증된 기타 모범 사례를 기반으로 일련의 휴리스틱와 비교하여 렌더링된 DOM을 감사합니다. 이들은 노골적인 접근성 위반을 적발하는 QA의 첫번째 라인 역할을 수행합니다.</p>\n<p>예를 들어, Axe는 평균적으로 <a href=\"https://www.deque.com/blog/automated-testing-study-identifies-57-percent-of-digital-accessibility-issues/\">WCAG 이슈의 57%를 자동적으로</a>찾아냅니다. 이를 통해 팀은 수동 검토가 필요한 더 복잡한 이슈에 전문가 자원을 집중할 수 있습니다.</p>\n<p>대부분의 기존 테스트 환경과 통합되므로 <a href=\"https://github.com/dequelabs/axe-core\">Axe library</a>를 사용하는 팀이 많습니다. 예를 들어, <a href=\"https://github.com/twilio-labs/paste\">Twilio Paste</a> 팀은 <a href=\"https://github.com/twilio-labs/paste/blob/cd0ddad508e41cb9982a693a5160f1b7866f4e2a/packages/paste-core/components/checkbox/__tests__/checkboxdisclaimer.test.tsx#L40\">jest-axe integration</a>를 사용합니다. 반면 Shopify Polaris와 Adobe Spectrum 팀들은 <a href=\"https://storybook.js.org/addons/@storybook/addon-a11y\">스토리북 애드온(Storybook addon)</a> 버전을 사용합니다.</p>\n<p>스토리북 애드온은 (jsdom을 위한 Jest와는 반대로) 브라우저에서 검사를 실행하므로 낮은 대비와 같은 문제들을 발견할 수 있습니다. 하지만 각 스토리(story)를 수동으로 확인해야 합니다.</p>\n<h2>접근성 테스팅 작업 흐름</h2>\n<p>개발 프로세스 전반에 걸쳐 이러한 검사를 실행하면 피드백 루프를 단축하고 문제를 더 빠르게 해결할 수 있습니다. 작업 흐름의 모양은 다음과 같습니다.</p>\n<ol>\n<li>👨🏽‍💻 <strong>개발 중:</strong> 스토리북을 사용하여 한 번에 하나의 컴포넌트에 집중할 수 있습니다. A11y 애드온을 사용해 시각적 결함을 시뮬레이션하고 컴포넌트 레벨에서 접근성 검사를 실행합니다.</li>\n<li>✅ <strong>QA의 경우:</strong> Axe 검사를 기능 테스트 파이프라인에 통합합니다. 모든 컴포넌트를 검사해 회귀를 탐지합니다.</li>\n</ol>\n<p><img src=\"/tutorials/ui-testing-handbook/a11y-workflow.png\" alt=\"\"></p>\n<p>실제 상황을 예시로 이 작업 흐름을 살펴보겠습니다.</p>\n<h3>접근성 애드온을 설치해보세요</h3>\n<p>스토리북의 접근성은 활성 스토리에 Axe를 실행합니다. 테스트 결과를 패널에 시각화하고 규칙을 위반한 모든 DOM 노드를 추려서 나타냅니다.</p>\n<p><img src=\"/tutorials/ui-testing-handbook/a11y-testing.gif\" alt=\"\"></p>\n<p>애드온을 설치하기 위해, <code>yarn add -D @storybook/addon-a11y</code>을 실행해보세요. 그 후 <code>'@storybook/addon-a11y'</code>를 <code>.storybook/main.js</code> 안에 있는 애드온 배열에 추가해보세요. -</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`module.exports = {\n  staticDirs: ['../public'],\n  stories: ['../src/**/*.stories.mdx', '../src/**/*.stories.@(js|jsx|ts|tsx)'],\n  addons: [\n    '@storybook/addon-links',\n    '@storybook/addon-essentials',\n    '@storybook/preset-create-react-app',\n   '@storybook/addon-a11y',\n    '@storybook/addon-interactions',\n  ],\n  core: {\n    builder: {\n      name: 'webpack5',\n    },\n  },\n  features:{\n    interactionsDebugger: true,\n  },\n  webpackFinal: async (config) => {\n    return {\n      ...config,\n      resolve: {\n        ...config.resolve,\n        alias: {\n          ...config.resolve.alias,\n          '@emotion/core': toPath('node_modules/@emotion/react'),\n          'emotion-theming': toPath('node_modules/@emotion/react'),\n        },\n      },\n    };\n  },\n};`, `98961224351059000000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"98961224351059000000\"\n              >\n                Copy \n              </div>\n            </div>\n<div class=\"gatsby-code-title\">.storybook/main.js</div>\n<pre><code class=\"language-diff\">module.exports = {\n  staticDirs: ['../public'],\n  stories: ['../src/**/*.stories.mdx', '../src/**/*.stories.@(js|jsx|ts|tsx)'],\n  addons: [\n    '@storybook/addon-links',\n    '@storybook/addon-essentials',\n    '@storybook/preset-create-react-app',\n+   '@storybook/addon-a11y',\n    '@storybook/addon-interactions',\n  ],\n  core: {\n    builder: {\n      name: 'webpack5',\n    },\n  },\n  features:{\n    interactionsDebugger: true,\n  },\n  webpackFinal: async (config) => {\n    return {\n      ...config,\n      resolve: {\n        ...config.resolve,\n        alias: {\n          ...config.resolve.alias,\n          '@emotion/core': toPath('node_modules/@emotion/react'),\n          'emotion-theming': toPath('node_modules/@emotion/react'),\n        },\n      },\n    };\n  },\n};\n</code></pre>\n<h3>작성한대로 접근성 테스트하기</h3>\n<p>우리는 이미 작업 컴포넌트를 <a href=\"/tutorials/ui-testing-handbook/react/ko/visual-testing/\">분리</a>했고 해당 사용례를 모두 스토리로 캡쳐했습니다. 개발 단계에서 이러한 사례를 순환하여 접근성 문제를 발견할 수 있습니다.</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`import React from 'react';\nimport { Task } from './Task';\n\nexport default {\n  component: Task,\n  title: 'Task',\n  argTypes: {\n    onArchiveTask: { action: 'onArchiveTask' },\n    onTogglePinTask: { action: 'onTogglePinTask' },\n    onEditTitle: { action: 'onEditTitle' },\n  },\n};\n\nconst Template = (args) => <Task {...args} />;\n\nexport const Default = Template.bind({});\nDefault.args = {\n  task: {\n    id: '1',\n    title: 'Buy milk',\n    state: 'TASK_INBOX',\n  },\n};\n\nexport const Pinned = Template.bind({});\nPinned.args = {\n  task: {\n    id: '2',\n    title: 'QA dropdown',\n    state: 'TASK_PINNED',\n  },\n};\n\nexport const Archived = Template.bind({});\nArchived.args = {\n  task: {\n    id: '3',\n    title: 'Write schema for account menu',\n    state: 'TASK_ARCHIVED',\n  },\n};\n\nconst longTitleString = \\`This task's name is absurdly large. In fact, I think if I keep going I might end up with content overflow. What will happen? The star that represents a pinned task could have text overlapping. The text could cut-off abruptly when it reaches the star. I hope not!\\`;\n\nexport const LongTitle = Template.bind({});\nLongTitle.args = {\n  task: {\n    id: '4',\n    title: longTitleString,\n    state: 'TASK_INBOX',\n  },\n};`, `32100108966985806000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"32100108966985806000\"\n              >\n                Copy \n              </div>\n            </div>\n<div class=\"gatsby-code-title\">src/components/Task.stories.js</div>\n<pre><code class=\"language-javascript\">import React from 'react';\nimport { Task } from './Task';\n\nexport default {\n  component: Task,\n  title: 'Task',\n  argTypes: {\n    onArchiveTask: { action: 'onArchiveTask' },\n    onTogglePinTask: { action: 'onTogglePinTask' },\n    onEditTitle: { action: 'onEditTitle' },\n  },\n};\n\nconst Template = (args) => &#x3C;Task {...args} />;\n\nexport const Default = Template.bind({});\nDefault.args = {\n  task: {\n    id: '1',\n    title: 'Buy milk',\n    state: 'TASK_INBOX',\n  },\n};\n\nexport const Pinned = Template.bind({});\nPinned.args = {\n  task: {\n    id: '2',\n    title: 'QA dropdown',\n    state: 'TASK_PINNED',\n  },\n};\n\nexport const Archived = Template.bind({});\nArchived.args = {\n  task: {\n    id: '3',\n    title: 'Write schema for account menu',\n    state: 'TASK_ARCHIVED',\n  },\n};\n\nconst longTitleString = `This task's name is absurdly large. In fact, I think if I keep going I might end up with content overflow. What will happen? The star that represents a pinned task could have text overlapping. The text could cut-off abruptly when it reaches the star. I hope not!`;\n\nexport const LongTitle = Template.bind({});\nLongTitle.args = {\n  task: {\n    id: '4',\n    title: longTitleString,\n    state: 'TASK_INBOX',\n  },\n};\n</code></pre>\n<p><img src=\"/tutorials/ui-testing-handbook/a11y-addon.png\" alt=\"\"></p>\n<p>애드온이 어떻게 두 개의 위반사항을 발견했는지 보세요. 첫 번째, <strong>“전경색과 배경색의 대비가 WCAG 2 AA 대비율 임계값을 충족하는지 확인하기”</strong> 는 <code>archived</code> 상태에 한정됩니다. 본질적으로 그것은 글과 배경의 대비가 충분하지 않음을 의미합니다. 텍스트 색상을 <code>gray.400</code>에서 <code>gray.600</code>처럼 약간 더 어두운 회색으로 변경함으로써 이 문제를 해결할 수 있습니다.</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`import React from 'react';\nimport PropTypes from 'prop-types';\nimport {\n Checkbox,\n Flex,\n IconButton,\n Input,\n Box,\n VisuallyHidden,\n} from '@chakra-ui/react';\nimport { StarIcon } from '@chakra-ui/icons';\n\nexport const Task = ({\n task: { id, title, state },\n onArchiveTask,\n onTogglePinTask,\n onEditTitle,\n ...props\n}) => (\n\n // code omitted for brevity\n\n   <Box width=&quot;full&quot; as=&quot;label&quot;>\n     <VisuallyHidden>Edit</VisuallyHidden>\n     <Input\n       variant=&quot;unstyled&quot;\n       flex=&quot;1 1 auto&quot;\n      color={state === 'TASK_ARCHIVED' ? 'gray.600' : 'gray.700'}\n       textDecoration={state === 'TASK_ARCHIVED' ? 'line-through' : 'none'}\n       fontSize=&quot;sm&quot;\n       isTruncated\n       value={title}\n       onChange={(e) => onEditTitle(e.target.value, id)}\n     />\n   </Box>\n\n   // code omitted for brevity\n </Flex>\n);\n\nTask.propTypes = {\n task: PropTypes.shape({\n   id: PropTypes.string.isRequired,\n   title: PropTypes.string.isRequired,\n   state: PropTypes.string.isRequired,\n }),\n onArchiveTask: PropTypes.func.isRequired,\n onTogglePinTask: PropTypes.func.isRequired,\n onEditTitle: PropTypes.func.isRequired,\n};`, `17517668178001890000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"17517668178001890000\"\n              >\n                Copy \n              </div>\n            </div>\n<div class=\"gatsby-code-title\">src/components/Task.js</div>\n<pre><code class=\"language-diff\">import React from 'react';\nimport PropTypes from 'prop-types';\nimport {\n Checkbox,\n Flex,\n IconButton,\n Input,\n Box,\n VisuallyHidden,\n} from '@chakra-ui/react';\nimport { StarIcon } from '@chakra-ui/icons';\n\nexport const Task = ({\n task: { id, title, state },\n onArchiveTask,\n onTogglePinTask,\n onEditTitle,\n ...props\n}) => (\n\n // code omitted for brevity\n\n   &#x3C;Box width=\"full\" as=\"label\">\n     &#x3C;VisuallyHidden>Edit&#x3C;/VisuallyHidden>\n     &#x3C;Input\n       variant=\"unstyled\"\n       flex=\"1 1 auto\"\n-      color={state === 'TASK_ARCHIVED' ? 'gray.400' : 'gray.700'}\n+      color={state === 'TASK_ARCHIVED' ? 'gray.600' : 'gray.700'}\n       textDecoration={state === 'TASK_ARCHIVED' ? 'line-through' : 'none'}\n       fontSize=\"sm\"\n       isTruncated\n       value={title}\n       onChange={(e) => onEditTitle(e.target.value, id)}\n     />\n   &#x3C;/Box>\n\n   // code omitted for brevity\n &#x3C;/Flex>\n);\n\nTask.propTypes = {\n task: PropTypes.shape({\n   id: PropTypes.string.isRequired,\n   title: PropTypes.string.isRequired,\n   state: PropTypes.string.isRequired,\n }),\n onArchiveTask: PropTypes.func.isRequired,\n onTogglePinTask: PropTypes.func.isRequired,\n onEditTitle: PropTypes.func.isRequired,\n};\n</code></pre>\n<p>두 번째 위반사항인 <strong>“<code>&#x3C;li></code> 요소가 의미있게 사용되도록 하기”</strong> 는 DOM 구조가 잘못되었음을 나타냅니다. Task 컴포넌트는 <code>&#x3C;li></code> 요소를 렌더링합니다. 따라서 우리는 이 스토리 안의 템플릿을 <code>&#x3C;ul></code> 엘레멘트가 감싸는 형태로 갱신해야 합니다.</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`import React from 'react';\nimport { Task } from './Task';\n\nexport default {\n  component: Task,\n  title: 'Task',\n  argTypes: {\n    onArchiveTask: { action: 'onArchiveTask' },\n    onTogglePinTask: { action: 'onTogglePinTask' },\n    onEditTitle: { action: 'onEditTitle' },\n  },\n};\n\nconst Template = (args) => (\n  <ul>\n    <Task {...args} />\n  </ul>\n);\n\n// ... code omitted for brevity`, `59315918813121880000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"59315918813121880000\"\n              >\n                Copy \n              </div>\n            </div>\n<div class=\"gatsby-code-title\">src/components/Task.stories.js</div>\n<pre><code class=\"language-js\">import React from 'react';\nimport { Task } from './Task';\n\nexport default {\n  component: Task,\n  title: 'Task',\n  argTypes: {\n    onArchiveTask: { action: 'onArchiveTask' },\n    onTogglePinTask: { action: 'onTogglePinTask' },\n    onEditTitle: { action: 'onEditTitle' },\n  },\n};\n\nconst Template = (args) => (\n  &#x3C;ul>\n    &#x3C;Task {...args} />\n  &#x3C;/ul>\n);\n\n// ... code omitted for brevity\n</code></pre>\n<p>이제 다른 모든 컴포넌트에도 이 프로세스를 반복할 수 있습니다.</p>\n<p>접근성 테스트를 스토리북에 통합하면 개발 작업 흐름을 간소화할 수 있습니다. 컴포넌트에서 작업할 때 다른 툴들 사이를 이동할 필요가 없습니다. 필요한 건 바로 여기 브라우저에 있습니다. 중염색체(제2색약),원형종(제1색약) 또는 청황 색맹 같은 시각적 장애도 시뮬레이션이 가능합니다.</p>\n<p><img src=\"/tutorials/ui-testing-handbook/vision-simulator.png\" alt=\"\"></p>\n<h3>테스트 러너를 이용하여 자동으로 회귀 잡기</h3>\n<p>때로는 한 컴포넌트의 변화가 우연히 다른 컴포넌트를 파괴할 수 있습니다. 이러한 회귀를 잡기 위해서는, 풀 리퀘스트를 열기 전에 모든 모든 스토리를 테스트하길 원할 것입니다. 그러나 접근성 애드온은 스토리를 볼 때에만 검사를 수행합니다. 테스트 러너를 이용하여 모든 스토리를 한번에 테스트 할 수 있습니다. 이는 독자적인 유틸리티이며(<a href=\"https://jestjs.io/\">Jest</a>와 <a href=\"https://playwright.dev/\">Playwright</a>에 기반함) 스토리들의 렌더링 에러를 검사합니다.</p>\n<p>Axe를 실행하기 위해 테스트 러너를 설정해 봅시다. 우선 <a href=\"https://github.com/abhinaba-ghosh/axe-playwright\">axe-playwright</a>를 설치할 것입니다.</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`yarn add -D axe-playwright`, `87117926963561640000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"87117926963561640000\"\n              >\n                Copy \n              </div>\n            </div>\n<pre><code class=\"language-shell\">yarn add -D axe-playwright\n</code></pre>\n<p>다음으로, Axe를 실행하고 위반 여부를 확인하는 <code>it</code> 블록을 추가합니다. Jest-axe는 <code>toHaveNoViolations</code> 라는 편리한 assertion을 제시하여 하나의 함수 호출로 위반 여부를 확인할 수 있습니다.</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`const { injectAxe, checkA11y } = require('axe-playwright');\n\nmodule.exports = {\n async preRender(page, context) {\n   await injectAxe(page);\n },\n async postRender(page, context) {\n   await checkA11y(page, '#root', {\n     detailedReport: true,\n     detailedReportOptions: {\n       html: true,\n     },\n   })\n },\n};`, `47386565132861680000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"47386565132861680000\"\n              >\n                Copy \n              </div>\n            </div>\n<div class=\"gatsby-code-title\">.storybook/test-runner.js</div>\n<pre><code class=\"language-javascript\">const { injectAxe, checkA11y } = require('axe-playwright');\n\nmodule.exports = {\n async preRender(page, context) {\n   await injectAxe(page);\n },\n async postRender(page, context) {\n   await checkA11y(page, '#root', {\n     detailedReport: true,\n     detailedReportOptions: {\n       html: true,\n     },\n   })\n },\n};\n</code></pre>\n<p><code>preRender</code> 와 <code>postRender</code>는 태스크 러너에게 추가적인 작업을 수행시키기 위한 설정을 가능하게 하는 편리한 훅들입니다. 우리는 이러한 훅을 이용하여 스토리에 Axe를 주입하고, 그리고 렌더링이 된다면 접근성 테스트를 수행합니다.</p>\n<p><code>checkA11y</code> 함수에 전달된 몇 옵션들을 주목하세요. 스토리의 루트 엘레멘트에 Axe를 설정하고, DOM 트리를 순회하면서 문제가 있는지 검사할 것입니다. 이것들은 발견한 이슈들에 대해서 자세한 레포트를 만들고, 접근성 규칙을 위반한 HTML 엘레먼트의 목록을 출력할 것입니다.</p>\n<p>이 테스트를 수행하기 위해, 하나의 터미널 창에서 <code>yarn storybook</code>을 통해 Storybook을 시작하고, 다른 터미널 창에서 <code>yarn test-storybook</code>을 통해 테스트 러너러를 수행하세요.</p>\n<p><img src=\"/tutorials/ui-testing-handbook/test-runner-ally.png\" alt=\"\"></p>\n<h2>통합 문제 파악</h2>\n<p>UI는 컴포넌트를 구성하고 데이터 및 API에 연결함으로써 조립됩니다. 그 과정에는 실패할 수 있는 지점들이 많이 있습니다. 다음에는 Cypress를 사용해 시스템의 모든 계층을 한 번에 테스트하여 통합 문제를 파악하는 방법에 대해 알아보겠습니다.</p>","frontmatter":{"title":"스토리북(Storybook)을 통한 접근성 테스트","description":"통합적인 툴 사용(integrated tooling)으로 빠른 피드백 제공","commit":"ef3fa29"},"fields":{"guide":"ui-testing-handbook","slug":"/ui-testing-handbook/react/ko/accessibility-testing/","chapter":"accessibility-testing","framework":"react","language":"ko","permalink":"https://storybook.js.org/tutorials/ui-testing-handbook/react/ko/accessibility-testing/","tutorialUpToDate":false}},"currentGuide":{"frontmatter":{"codeGithubUrl":"https://github.com/chromaui/ui-testing-guide-code","toc":["introduction","visual-testing","composition-testing","interaction-testing","accessibility-testing","user-flow-testing","automate","workflow","conclusion"],"title":"UI Testing Handbook","twitterShareText":"I'm learning how to test UIs! This will help me ship UIs without worrying about stowaway bugs."}},"site":{"siteMetadata":{"title":"Storybook Tutorials","githubUrl":"https://github.com/chromaui/learnstorybook.com","contributeUrl":"https://github.com/chromaui/learnstorybook.com/#contribute","permalink":"https://storybook.js.org/tutorials","siteUrl":"https://storybook.js.org"}},"tocPages":{"edges":[{"node":{"frontmatter":{"tocTitle":"접근성","title":"스토리북(Storybook)을 통한 접근성 테스트","description":"통합적인 툴 사용(integrated tooling)으로 빠른 피드백 제공"},"fields":{"slug":"/ui-testing-handbook/react/ko/accessibility-testing/","framework":"react","chapter":"accessibility-testing"}}},{"node":{"frontmatter":{"tocTitle":"자동화(Automate)","title":"깃허브(Github) 액션으로 UI 테스트 자동화하기","description":"작업 흐름(workflow)을 더 빠르게 만들고, 더 고품질의 코드를 전달하기"},"fields":{"slug":"/ui-testing-handbook/react/ko/automate/","framework":"react","chapter":"automate"}}},{"node":{"frontmatter":{"tocTitle":"구성","title":"구성 테스트","description":"사소한 변경이 커다란 회귀로 변하는 것을 방지하기"},"fields":{"slug":"/ui-testing-handbook/react/ko/composition-testing/","framework":"react","chapter":"composition-testing"}}},{"node":{"frontmatter":{"tocTitle":"마무리","title":"마무리","description":"적게 손대고 더 많은 게 해결되도록 하자"},"fields":{"slug":"/ui-testing-handbook/react/ko/conclusion/","framework":"react","chapter":"conclusion"}}},{"node":{"frontmatter":{"tocTitle":"상호작용","title":"컴포넌트 상호작용 테스트하기","description":"사용자의 동작을 시뮬레이션하고 기능별 검사를 실행하는 방법 알아보기"},"fields":{"slug":"/ui-testing-handbook/react/ko/interaction-testing/","framework":"react","chapter":"interaction-testing"}}},{"node":{"frontmatter":{"tocTitle":"소개","title":"UI 테스트 소개","description":"UI 테스트를 위한 최신 개발 방법"},"fields":{"slug":"/ui-testing-handbook/react/ko/introduction/","framework":"react","chapter":"introduction"}}},{"node":{"frontmatter":{"tocTitle":"사용자 플로우(User flow)","title":"사용자 플로우(user flow) 테스트하기","description":"UI가 전체적으로 작동하는지 확인해보세요"},"fields":{"slug":"/ui-testing-handbook/react/ko/user-flow-testing/","framework":"react","chapter":"user-flow-testing"}}},{"node":{"frontmatter":{"tocTitle":"시각적 요소 테스트","title":"스토리북(Storybook)의 시각적 요소 테스트","description":"UI 버그를 자동으로 찾아내는 방법 알아보기"},"fields":{"slug":"/ui-testing-handbook/react/ko/visual-testing/","framework":"react","chapter":"visual-testing"}}},{"node":{"frontmatter":{"tocTitle":"작업 흐름(Workflow)","title":"UI 테스팅 플레이북","description":"우리를 느리게 하지 않는 테스팅 작업 흐름(workflow)"},"fields":{"slug":"/ui-testing-handbook/react/ko/workflow/","framework":"react","chapter":"workflow"}}}]},"translationPages":{"edges":[{"node":{"frontmatter":{"tocTitle":"Accessibility","title":"Accessibility testing with Storybook","description":"Fast feedback with integrated tooling"},"fields":{"slug":"/ui-testing-handbook/react/en/accessibility-testing/","framework":"react","chapter":"accessibility-testing","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Automate","title":"How to automate UI tests with Github Actions","description":"Speed up your workflow and ship higher quality of code"},"fields":{"slug":"/ui-testing-handbook/react/en/automate/","framework":"react","chapter":"automate","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Conclusion","title":"Conclusion","description":"Get more done by doing less"},"fields":{"slug":"/ui-testing-handbook/react/en/conclusion/","framework":"react","chapter":"conclusion","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Interaction","title":"Testing component interactions","description":"Learn how to simulate user behaviour and run functional checks"},"fields":{"slug":"/ui-testing-handbook/react/en/interaction-testing/","framework":"react","chapter":"interaction-testing","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Introduction","title":"Introduction to testing UIs","description":"Latest production-ready techniques for testing UIs"},"fields":{"slug":"/ui-testing-handbook/react/en/introduction/","framework":"react","chapter":"introduction","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"User flow","title":"Testing user flows","description":"Verify that your UI works end-to-end"},"fields":{"slug":"/ui-testing-handbook/react/en/user-flow-testing/","framework":"react","chapter":"user-flow-testing","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Visual","title":"Visual testing in Storybook","description":"Learn how to pinpoint UI bugs automatically"},"fields":{"slug":"/ui-testing-handbook/react/en/visual-testing/","framework":"react","chapter":"visual-testing","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Workflow","title":"UI Testing Playbook","description":"A testing workflow that doesn’t slow you down"},"fields":{"slug":"/ui-testing-handbook/react/en/workflow/","framework":"react","chapter":"workflow","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"접근성","title":"스토리북(Storybook)을 통한 접근성 테스트","description":"통합적인 툴 사용(integrated tooling)으로 빠른 피드백 제공"},"fields":{"slug":"/ui-testing-handbook/react/ko/accessibility-testing/","framework":"react","chapter":"accessibility-testing","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"자동화(Automate)","title":"깃허브(Github) 액션으로 UI 테스트 자동화하기","description":"작업 흐름(workflow)을 더 빠르게 만들고, 더 고품질의 코드를 전달하기"},"fields":{"slug":"/ui-testing-handbook/react/ko/automate/","framework":"react","chapter":"automate","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"구성","title":"구성 테스트","description":"사소한 변경이 커다란 회귀로 변하는 것을 방지하기"},"fields":{"slug":"/ui-testing-handbook/react/ko/composition-testing/","framework":"react","chapter":"composition-testing","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"마무리","title":"마무리","description":"적게 손대고 더 많은 게 해결되도록 하자"},"fields":{"slug":"/ui-testing-handbook/react/ko/conclusion/","framework":"react","chapter":"conclusion","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"상호작용","title":"컴포넌트 상호작용 테스트하기","description":"사용자의 동작을 시뮬레이션하고 기능별 검사를 실행하는 방법 알아보기"},"fields":{"slug":"/ui-testing-handbook/react/ko/interaction-testing/","framework":"react","chapter":"interaction-testing","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"소개","title":"UI 테스트 소개","description":"UI 테스트를 위한 최신 개발 방법"},"fields":{"slug":"/ui-testing-handbook/react/ko/introduction/","framework":"react","chapter":"introduction","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"사용자 플로우(User flow)","title":"사용자 플로우(user flow) 테스트하기","description":"UI가 전체적으로 작동하는지 확인해보세요"},"fields":{"slug":"/ui-testing-handbook/react/ko/user-flow-testing/","framework":"react","chapter":"user-flow-testing","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"시각적 요소 테스트","title":"스토리북(Storybook)의 시각적 요소 테스트","description":"UI 버그를 자동으로 찾아내는 방법 알아보기"},"fields":{"slug":"/ui-testing-handbook/react/ko/visual-testing/","framework":"react","chapter":"visual-testing","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"작업 흐름(Workflow)","title":"UI 테스팅 플레이북","description":"우리를 느리게 하지 않는 테스팅 작업 흐름(workflow)"},"fields":{"slug":"/ui-testing-handbook/react/ko/workflow/","framework":"react","chapter":"workflow","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"Composition","title":"Testing composite components","description":"Prevent minor changes from turning into major regressions"},"fields":{"slug":"/ui-testing-handbook/react/en/composition-testing/","framework":"react","chapter":"composition-testing","language":"en"}}}]}},"pageContext":{"guide":"ui-testing-handbook","slug":"/ui-testing-handbook/react/ko/accessibility-testing/","framework":"react","language":"ko","chapter":"accessibility-testing","pageType":"chapter"}},"staticQueryHashes":["238248339"]}