{"componentChunkName":"component---src-components-screens-chapter-screen-index-js","path":"/visual-testing-handbook/react/en/vtdd/","result":{"data":{"currentPage":{"html":"<p>Now that the basics are covered let’s jump into the details. This example demonstrates building out a state of a <code>CommentList</code> component using <strong>Visual TDD</strong> with Storybook.</p>\n<ol>\n<li>Build visual test cases</li>\n<li>Check the tests in Storybook</li>\n<li>Build out the implementation</li>\n<li>Check the implementation against the design</li>\n<li>Iterate</li>\n</ol>\n<h3>What we're building</h3>\n<p><code>CommentList</code> is part of a chat tool for galactic freedom fighters. Our designer has handed us a design for the various ways the list of comments should look based on the data and the app's state. Our job is to ensure the list renders correctly in terms of the exact text, images displayed, and visual treatment.</p>\n<p><img src=\"/tutorials/visual-testing-handbook/visual-testing-handbook-commentlist-design-optimized.png\" alt=\"Commentlist design spec\"></p>\n<h3>1. Build visual test cases</h3>\n<p>Start visual TDD by building test cases. We’ll create three cases that match the three images above. A strict TDD-er would say we need to develop and implement one test case at a time; it’s up to you if you think this helps your process.</p>\n<p>Let's set up the example project using <a href=\"https://github.com/Rich-Harris/degit\">degit</a> to download the necessary boilerplate templates (partially built applications with some default configuration). Run the following commands:</p>\n<pre><code class=\"language-shell\"># Clone the template for this tutorial\nnpx degit chromaui/visual-testing-handbook-react-template commentlist\n\ncd commentlist\n\n# Install dependencies\nyarn\n</code></pre>\n<p>Next, we’ll build the simplest-possible <code>CommentList</code> implementation so that we can ensure our tests are set up correctly.</p>\n<p>Inside your <code>src</code> directory, create a new folder called <code>components</code>, then by a new file called <code>CommentList.jsx</code> with the following content:</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`import PropTypes from 'prop-types';\n\nexport default function CommentList({ loading, comments, totalCount }) {\n  if (loading) {\n    return <div>loading</div>;\n  }\n  if (comments.length === 0) {\n    return <div>empty</div>;\n  }\n  return (\n    <div>\n      {comments.length} of {totalCount}\n    </div>\n  );\n}\n\nCommentList.propTypes = {\n  /**\n   * Is the component in the loading state\n   */\n  loading: PropTypes.bool,\n\n  /**\n   * Total number of comments\n   */\n  totalCount: PropTypes.number,\n  /**\n   * List of comments\n   */\n  comments: PropTypes.arrayOf(\n    PropTypes.shape({\n      text: PropTypes.string,\n      author: PropTypes.shape({\n        name: PropTypes.string,\n        avatar: PropTypes.string,\n      }),\n    })\n  ),\n};\n\nCommentList.defaultProps = {\n  loading: false,\n  totalCount: 10,\n  comments: [],\n};`, `88896856278567730000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"88896856278567730000\"\n              >\n                Copy \n              </div>\n            </div>\n<div class=\"gatsby-code-title\">src/components/CommentList.jsx</div>\n<pre><code class=\"language-jsx\">import PropTypes from 'prop-types';\n\nexport default function CommentList({ loading, comments, totalCount }) {\n  if (loading) {\n    return &#x3C;div>loading&#x3C;/div>;\n  }\n  if (comments.length === 0) {\n    return &#x3C;div>empty&#x3C;/div>;\n  }\n  return (\n    &#x3C;div>\n      {comments.length} of {totalCount}\n    &#x3C;/div>\n  );\n}\n\nCommentList.propTypes = {\n  /**\n   * Is the component in the loading state\n   */\n  loading: PropTypes.bool,\n\n  /**\n   * Total number of comments\n   */\n  totalCount: PropTypes.number,\n  /**\n   * List of comments\n   */\n  comments: PropTypes.arrayOf(\n    PropTypes.shape({\n      text: PropTypes.string,\n      author: PropTypes.shape({\n        name: PropTypes.string,\n        avatar: PropTypes.string,\n      }),\n    })\n  ),\n};\n\nCommentList.defaultProps = {\n  loading: false,\n  totalCount: 10,\n  comments: [],\n};\n</code></pre>\n<p>Now that we have a basic implementation, we can build our test states. Storybook makes this quick and easy.</p>\n<p>Create a new file called <code>CommentList.stories.js</code> in <code>src/components</code> and add the following:</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`import CommentList from './CommentList';\n\nexport default {\n  component: CommentList,\n  title: 'CommentList',\n};\n\nexport const Paginated = {\n  args: {\n    comments: [\n      {\n        text: 'Lorem ipsum dolor sit amet, consectetur adipisicing elit.',\n        author: {\n          name: 'Luke',\n          avatar: 'luke.jpeg',\n        },\n      },\n      {\n        text: 'Ut enim ad minim veniam, quis nostrud exercitation ullamco.',\n        author: {\n          name: 'Leah',\n          avatar: 'leah.jpeg',\n        },\n      },\n      {\n        text: 'Duis aute irure dolor in reprehenderit in voluptate.',\n        author: {\n          name: 'Han',\n          avatar: 'han.jpeg',\n        },\n      },\n      {\n        text: 'Ut enim ad minim veniam, quis nostrud exercitation ullamco.',\n        author: {\n          name: 'Poe',\n          avatar: 'poe.jpeg',\n        },\n      },\n      {\n        text: 'Duis aute irure dolor in reprehenderit in voluptate.',\n        author: {\n          name: 'Finn',\n          avatar: 'finn.jpeg',\n        },\n      },\n    ],\n    totalCount: 10,\n  },\n};\n\nexport const HasData = {\n  args: {\n    comments: [...Paginated.args.comments.slice(0, 3)],\n    totalCount: 3,\n  },\n};\n\nexport const Loading = {\n  args: {\n    comments: [],\n    Loading: true,\n  },\n};\n\nexport const Empty = {\n  args: {\n    ...Loading.args,\n    loading: false,\n  },\n};`, `21904719977941324000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"21904719977941324000\"\n              >\n                Copy \n              </div>\n            </div>\n<div class=\"gatsby-code-title\">src/components/CommentList.stories.js</div>\n<pre><code class=\"language-js\">import CommentList from './CommentList';\n\nexport default {\n  component: CommentList,\n  title: 'CommentList',\n};\n\nexport const Paginated = {\n  args: {\n    comments: [\n      {\n        text: 'Lorem ipsum dolor sit amet, consectetur adipisicing elit.',\n        author: {\n          name: 'Luke',\n          avatar: 'luke.jpeg',\n        },\n      },\n      {\n        text: 'Ut enim ad minim veniam, quis nostrud exercitation ullamco.',\n        author: {\n          name: 'Leah',\n          avatar: 'leah.jpeg',\n        },\n      },\n      {\n        text: 'Duis aute irure dolor in reprehenderit in voluptate.',\n        author: {\n          name: 'Han',\n          avatar: 'han.jpeg',\n        },\n      },\n      {\n        text: 'Ut enim ad minim veniam, quis nostrud exercitation ullamco.',\n        author: {\n          name: 'Poe',\n          avatar: 'poe.jpeg',\n        },\n      },\n      {\n        text: 'Duis aute irure dolor in reprehenderit in voluptate.',\n        author: {\n          name: 'Finn',\n          avatar: 'finn.jpeg',\n        },\n      },\n    ],\n    totalCount: 10,\n  },\n};\n\nexport const HasData = {\n  args: {\n    comments: [...Paginated.args.comments.slice(0, 3)],\n    totalCount: 3,\n  },\n};\n\nexport const Loading = {\n  args: {\n    comments: [],\n    Loading: true,\n  },\n};\n\nexport const Empty = {\n  args: {\n    ...Loading.args,\n    loading: false,\n  },\n};\n</code></pre>\n<h3>2. Check the tests in Storybook</h3>\n<p>Start Storybook to see the test cases. Our component implementation is bare bones, but it allows us to confirm our test cases render as intended.</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`yarn storybook`, `65895252823516580000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"65895252823516580000\"\n              >\n                Copy \n              </div>\n            </div>\n<pre><code class=\"language-shell\">yarn storybook\n</code></pre>\n<video autoPlay muted playsInline loop>\n  <source\n    src=\"/tutorials/visual-testing-handbook/commentlist-initial-state-optimized.mp4\"\n    type=\"video/mp4\"/>\n</video>\n<h3>3. Build out the implementation</h3>\n<p>So far, we scaffolded a rudimentary implementation then set up Storybook to render our test cases. It’s time to start building an implementation of the <code>HasData</code> variation in isolation.</p>\n<p>We use <a href=\"https://styled-components.com/\"><code>styled-components</code></a> – a library that encapsulates CSS at the component level. Run the following command:</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`yarn add styled-components`, `23052628880017690000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"23052628880017690000\"\n              >\n                Copy \n              </div>\n            </div>\n<pre><code class=\"language-shell\">yarn add styled-components\n</code></pre>\n<p>Update your <code>CommentList.js</code> file to the following:</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`import PropTypes from 'prop-types';\n\n import styled, { createGlobalStyle } from 'styled-components';\n\n const CommentListDiv = styled.div\\`\n   font-family: &quot;Nunito Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif;\n   color: #333;\n   display: inline-block;\n   vertical-align: top;\n   width: 265px;\n \\`;\n\n const CommentItemDiv = styled.div\\`\n   font-size: 12px;\n   line-height: 14px;\n   clear: both;\n   height: 48px;\n   margin-bottom: 10px;\n   box-shadow: rgba(0, 0, 0, 0.2) 0 0 10px 0;\n   background: linear-gradient(\n    120deg,\n    rgba(248, 248, 254, 0.95),\n    rgba(250, 250, 250, 0.95)\n   );\n   border-radius: 48px;\n \\`;\n\n const AvatarDiv = styled.div\\`\n   float: left;\n   position: relative;\n   overflow: hidden;\n   height: 48px;\n   width: 48px;\n   margin-right: 14px;\n   background: #dfecf2;\n   border-radius: 48px;\n \\`;\n\n const AvatarImg = styled.img\\`\n   position: absolute;\n   height: 100%;\n   width: 100%;\n   left: 0;\n   top: 0;\n   z-index: 1;\n   background: #999;\n \\`;\n\n const MessageDiv = styled.div\\`\n   overflow: hidden;\n   padding-top: 10px;\n   padding-right: 20px;\n \\`;\n\n const AuthorSpan = styled.span\\`\n   font-weight: bold;\n \\`;\n\n const TextSpan = styled.span\\`\\`;\n\n const GlobalStyle = createGlobalStyle\\`\n   @import url('https://fonts.googleapis.com/css?family=Nunito+Sans:400,400i,800');\n \\`;\n\nexport default function CommentList({ loading, comments, totalCount }) {\n  if (loading) {\n    return <div>loading</div>;\n  }\n  if (comments.length === 0) {\n    return <div>empty</div>;\n  }\n  return (\n   <>\n   <GlobalStyle/>\n   <CommentListDiv>\n     {comments.map(({ text, author: { name, avatar } }) => (\n       <CommentItemDiv key={\\`comment_\\${name}\\`}>\n         <AvatarDiv>\n           <AvatarImg src={avatar} />\n         </AvatarDiv>\n         <MessageDiv>\n           <AuthorSpan>{name}</AuthorSpan> <TextSpan>{text}</TextSpan>\n         </MessageDiv>\n       </CommentItemDiv>\n     ))}\n   </CommentListDiv>\n   </>\n  );\n}\n\nCommentList.propTypes = {\n  /**\n   * Is the component in the loading state\n   */\n  loading: PropTypes.bool,\n\n  /**\n   * Total number of comments\n   */\n  totalCount: PropTypes.number,\n  /**\n   * List of comments\n   */\n  comments: PropTypes.arrayOf(\n    PropTypes.shape({\n      text: PropTypes.string,\n      author: PropTypes.shape({\n        name: PropTypes.string,\n        avatar: PropTypes.string,\n      }),\n    })\n  ),\n};\n\nCommentList.defaultProps = {\n  loading: false,\n  totalCount: 10,\n  comments: [],\n};`, `61576653181771570000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"61576653181771570000\"\n              >\n                Copy \n              </div>\n            </div>\n<div class=\"gatsby-code-title\">src/components/CommentList.jsx</div>\n<pre><code class=\"language-diff\">import PropTypes from 'prop-types';\n\n+ import styled, { createGlobalStyle } from 'styled-components';\n\n+ const CommentListDiv = styled.div`\n+   font-family: \"Nunito Sans\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n+   color: #333;\n+   display: inline-block;\n+   vertical-align: top;\n+   width: 265px;\n+ `;\n\n+ const CommentItemDiv = styled.div`\n+   font-size: 12px;\n+   line-height: 14px;\n+   clear: both;\n+   height: 48px;\n+   margin-bottom: 10px;\n+   box-shadow: rgba(0, 0, 0, 0.2) 0 0 10px 0;\n+   background: linear-gradient(\n+    120deg,\n+    rgba(248, 248, 254, 0.95),\n+    rgba(250, 250, 250, 0.95)\n+   );\n+   border-radius: 48px;\n+ `;\n\n+ const AvatarDiv = styled.div`\n+   float: left;\n+   position: relative;\n+   overflow: hidden;\n+   height: 48px;\n+   width: 48px;\n+   margin-right: 14px;\n+   background: #dfecf2;\n+   border-radius: 48px;\n+ `;\n\n+ const AvatarImg = styled.img`\n+   position: absolute;\n+   height: 100%;\n+   width: 100%;\n+   left: 0;\n+   top: 0;\n+   z-index: 1;\n+   background: #999;\n+ `;\n\n+ const MessageDiv = styled.div`\n+   overflow: hidden;\n+   padding-top: 10px;\n+   padding-right: 20px;\n+ `;\n\n+ const AuthorSpan = styled.span`\n+   font-weight: bold;\n+ `;\n\n+ const TextSpan = styled.span``;\n\n+ const GlobalStyle = createGlobalStyle`\n+   @import url('https://fonts.googleapis.com/css?family=Nunito+Sans:400,400i,800');\n+ `;\n\nexport default function CommentList({ loading, comments, totalCount }) {\n  if (loading) {\n    return &#x3C;div>loading&#x3C;/div>;\n  }\n  if (comments.length === 0) {\n    return &#x3C;div>empty&#x3C;/div>;\n  }\n  return (\n+   &#x3C;>\n+   &#x3C;GlobalStyle/>\n+   &#x3C;CommentListDiv>\n+     {comments.map(({ text, author: { name, avatar } }) => (\n+       &#x3C;CommentItemDiv key={`comment_${name}`}>\n+         &#x3C;AvatarDiv>\n+           &#x3C;AvatarImg src={avatar} />\n+         &#x3C;/AvatarDiv>\n+         &#x3C;MessageDiv>\n+           &#x3C;AuthorSpan>{name}&#x3C;/AuthorSpan> &#x3C;TextSpan>{text}&#x3C;/TextSpan>\n+         &#x3C;/MessageDiv>\n+       &#x3C;/CommentItemDiv>\n+     ))}\n+   &#x3C;/CommentListDiv>\n+   &#x3C;/>\n  );\n}\n\nCommentList.propTypes = {\n  /**\n   * Is the component in the loading state\n   */\n  loading: PropTypes.bool,\n\n  /**\n   * Total number of comments\n   */\n  totalCount: PropTypes.number,\n  /**\n   * List of comments\n   */\n  comments: PropTypes.arrayOf(\n    PropTypes.shape({\n      text: PropTypes.string,\n      author: PropTypes.shape({\n        name: PropTypes.string,\n        avatar: PropTypes.string,\n      }),\n    })\n  ),\n};\n\nCommentList.defaultProps = {\n  loading: false,\n  totalCount: 10,\n  comments: [],\n};\n</code></pre>\n<h3>4. Check the implementation against the design</h3>\n<p>Check how the component looks in Storybook. This example provided the CSS already, but in practice, we would tweak the styles and confirmed them in Storybook as we went along.</p>\n<video autoPlay muted playsInline loop>\n  <source\n    src=\"/tutorials/visual-testing-handbook/commentlist-finished-state-optimized.mp4\"\n    type=\"video/mp4\"/>\n</video>\n<h3>5. Iterate</h3>\n<p>If we're not satisfied with the implementation in step 4, we'd go back to step 3 and keep working on it. If the UI matches the spec, then we'll move on to building the next variation - perhaps by adding the “load more” button to the <code>Paginated</code> story.</p>\n<p>As we iterate through this workflow, regularly check each story to ensure that the final implementation correctly handles each test state and not just the last one we worked on.</p>\n<h2>Learn how to automate visual testing</h2>\n<p>In the next chapter, we’ll see how we can automate the VTDD process with <a href=\"https://www.chromatic.com/?utm_source=storybook_website&#x26;utm_medium=link&#x26;utm_campaign=storybook\">Chromatic</a>, a free visual testing service made by the Storybook maintainers.</p>","frontmatter":{"title":"Visual TDD","description":"Write your first visual tests","commit":"d260c8d"},"fields":{"guide":"visual-testing-handbook","slug":"/visual-testing-handbook/react/en/vtdd/","chapter":"vtdd","framework":"react","language":"en","permalink":"https://storybook.js.org/tutorials/visual-testing-handbook/react/en/vtdd/","tutorialUpToDate":true}},"currentGuide":{"frontmatter":{"codeGithubUrl":"https://github.com/chromaui/learnstorybook-visual-testing-code","toc":["introduction","component-explorers","workflow","vtdd","automate","conclusion"],"title":"Visual Testing Handbook","twitterShareText":"I’m learning how to visual test UIs with Storybook! It’s great for finding UI bugs automatically."}},"site":{"siteMetadata":{"title":"Storybook Tutorials","githubUrl":"https://github.com/chromaui/learnstorybook.com","contributeUrl":"https://github.com/chromaui/learnstorybook.com/#contribute","permalink":"https://storybook.js.org/tutorials","siteUrl":"https://storybook.js.org"}},"tocPages":{"edges":[{"node":{"frontmatter":{"tocTitle":"Automate","title":"Automate visual testing","description":"Automate visual testing to catch regressions"},"fields":{"slug":"/visual-testing-handbook/react/en/automate/","framework":"react","chapter":"automate"}}},{"node":{"frontmatter":{"tocTitle":"Component explorers","title":"Component explorers","description":"A tool for UI development and visual testing"},"fields":{"slug":"/visual-testing-handbook/react/en/component-explorers/","framework":"react","chapter":"component-explorers"}}},{"node":{"frontmatter":{"tocTitle":"Conclusion","title":"Conclusion","description":"Say bye to visual bugs"},"fields":{"slug":"/visual-testing-handbook/react/en/conclusion/","framework":"react","chapter":"conclusion"}}},{"node":{"frontmatter":{"tocTitle":"Introduction","title":"Introduction to visual testing","description":"The pragmatic way to test user interfaces"},"fields":{"slug":"/visual-testing-handbook/react/en/introduction/","framework":"react","chapter":"introduction"}}},{"node":{"frontmatter":{"tocTitle":null,"title":"Visual TDD","description":"Write your first visual tests"},"fields":{"slug":"/visual-testing-handbook/react/en/vtdd/","framework":"react","chapter":"vtdd"}}},{"node":{"frontmatter":{"tocTitle":null,"title":"Workflow","description":"A test-driven workflow for building components"},"fields":{"slug":"/visual-testing-handbook/react/en/workflow/","framework":"react","chapter":"workflow"}}}]},"translationPages":{"edges":[{"node":{"frontmatter":{"tocTitle":"Automate","title":"Automate visual testing","description":"Automate visual testing to catch regressions"},"fields":{"slug":"/visual-testing-handbook/react/en/automate/","framework":"react","chapter":"automate","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Component explorers","title":"Component explorers","description":"A tool for UI development and visual testing"},"fields":{"slug":"/visual-testing-handbook/react/en/component-explorers/","framework":"react","chapter":"component-explorers","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Conclusion","title":"Conclusion","description":"Say bye to visual bugs"},"fields":{"slug":"/visual-testing-handbook/react/en/conclusion/","framework":"react","chapter":"conclusion","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Introduction","title":"Introduction to visual testing","description":"The pragmatic way to test user interfaces"},"fields":{"slug":"/visual-testing-handbook/react/en/introduction/","framework":"react","chapter":"introduction","language":"en"}}},{"node":{"frontmatter":{"tocTitle":null,"title":"Visual TDD","description":"Write your first visual tests"},"fields":{"slug":"/visual-testing-handbook/react/en/vtdd/","framework":"react","chapter":"vtdd","language":"en"}}},{"node":{"frontmatter":{"tocTitle":null,"title":"Workflow","description":"A test-driven workflow for building components"},"fields":{"slug":"/visual-testing-handbook/react/en/workflow/","framework":"react","chapter":"workflow","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Automatizar","title":"Automatizar las pruebas visuales","description":"Automatice las pruebas visuales para detectar regresiones"},"fields":{"slug":"/visual-testing-handbook/react/es/automate/","framework":"react","chapter":"automate","language":"es"}}},{"node":{"frontmatter":{"tocTitle":"Exploradores de componentes","title":"Exploradores de componentes","description":"Una herramienta para el desarrollo de la UI y las pruebas visuales"},"fields":{"slug":"/visual-testing-handbook/react/es/component-explorers/","framework":"react","chapter":"component-explorers","language":"es"}}},{"node":{"frontmatter":{"tocTitle":"Conclusión","title":"Conclusión","description":"Di adiós a los errores visuales"},"fields":{"slug":"/visual-testing-handbook/react/es/conclusion/","framework":"react","chapter":"conclusion","language":"es"}}},{"node":{"frontmatter":{"tocTitle":"Introducción","title":"Introducción a las pruebas visuales","description":"La manera pragmática de probar interfaces de usuario"},"fields":{"slug":"/visual-testing-handbook/react/es/introduction/","framework":"react","chapter":"introduction","language":"es"}}},{"node":{"frontmatter":{"tocTitle":null,"title":"TDD Visual","description":"Escribe tus primeras pruebas visuales"},"fields":{"slug":"/visual-testing-handbook/react/es/vtdd/","framework":"react","chapter":"vtdd","language":"es"}}},{"node":{"frontmatter":{"tocTitle":null,"title":"Flujo de trabajo","description":"Un flujo de trabajo guiado por pruebas para la construcción de componentes"},"fields":{"slug":"/visual-testing-handbook/react/es/workflow/","framework":"react","chapter":"workflow","language":"es"}}},{"node":{"frontmatter":{"tocTitle":"자동화","title":"시각적 테스트 자동화","description":"회귀 오류를 잡기 위해 시각적 테스트를 자동화하기"},"fields":{"slug":"/visual-testing-handbook/react/ko/automate/","framework":"react","chapter":"automate","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"컴포넌트 탐색기","title":"컴포넌트 탐색기","description":"UI 개발과 시각적 테스팅을 위한 도구"},"fields":{"slug":"/visual-testing-handbook/react/ko/component-explorer/","framework":"react","chapter":"component-explorer","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"마무리","title":"마무리","description":"시각적 버그들에 안녕을"},"fields":{"slug":"/visual-testing-handbook/react/ko/conclusion/","framework":"react","chapter":"conclusion","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"소개","title":"시각적 테스팅 소개","description":"UI를 테스트하는 실용적인 방법"},"fields":{"slug":"/visual-testing-handbook/react/ko/introduction/","framework":"react","chapter":"introduction","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":null,"title":"시각적 TDD","description":"첫 번째 시각적 테스트를 만들어보세요"},"fields":{"slug":"/visual-testing-handbook/react/ko/vtdd/","framework":"react","chapter":"vtdd","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":null,"title":"작업 흐름(Work Flow)","description":"컴포넌트 설계를 위한 테스트 주도(test-driven) 작업 흐름(workflow)"},"fields":{"slug":"/visual-testing-handbook/react/ko/workflow/","framework":"react","chapter":"workflow","language":"ko"}}}]}},"pageContext":{"guide":"visual-testing-handbook","slug":"/visual-testing-handbook/react/en/vtdd/","framework":"react","language":"en","chapter":"vtdd","pageType":"chapter"}},"staticQueryHashes":["238248339"]}