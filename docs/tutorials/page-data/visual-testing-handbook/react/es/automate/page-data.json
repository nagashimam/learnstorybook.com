{"componentChunkName":"component---src-components-screens-chapter-screen-index-js","path":"/visual-testing-handbook/react/es/automate/","result":{"data":{"currentPage":{"html":"<p>En el curso natural del desarrollo, los errores son inevitables. La automatizaciÃ³n de pruebas visuales utiliza mÃ¡quinas para detectar cambios en la apariencia de la interfaz de usuario para que los revise un humano.</p>\n<p>En pocas palabras, se toma una instantÃ¡nea de cada variaciÃ³n de los componentes. Esto sirve como \"lÃ­nea base\" de la prueba visual. Con cada commit, se capturan nuevas instantÃ¡neas y luego se comparan pÃ­xel por pÃ­xel con las lÃ­neas base. Si hay cambios en la interfaz de usuario, se le notificarÃ¡ para que revise si son errores o actualizaciones intencionales.</p>\n<video autoPlay muted playsInline loop >\n  <source\n    src=\"/tutorials/visual-testing-handbook/automate-visual-workflow-test-diff.mp4\"\n    type=\"video/mp4\"\n  />\n</video>\n<h2>Configure un repositorio en GitHub</h2>\n<p>Antes de comenzar, nuestro cÃ³digo local <code>CommentList</code> debe sincronizarse con un servicio de control de versiones remoto.</p>\n<p>Vaya a GitHub y cree un nuevo repositorio para el proyecto <a href=\"https://github.com/new\">aquÃ­</a>. Nombre el repositorio \"commentlist\", igual que nuestro proyecto local.</p>\n<p><img src=\"/tutorials/visual-testing-handbook/commentlist-gh-repo-optimized.png\" alt=\"Configure el repositorio de &#x27;comment list&#x27; en GitHub\"></p>\n<p>Luego, siga las instrucciones para configurar el repositorio. Reemplace <code>your-username</code> con el nombre de tu cuenta de GitHub.</p>\n<pre><code class=\"language-shell\">git init\ngit add .\ngit commit -m \"first commit\"\ngit branch -M main\ngit remote add origin https://github.com/your-username/commentlist.git\ngit push -u origin main\n</code></pre>\n<h2>Configure Chromatic</h2>\n<p>Usaremos los mantenedores de Chromatic by Storybook para demostrar el proceso de captura de imÃ¡genes. Vaya a <a href=\"https://www.chromatic.com/?utm_source=storybook_website&#x26;utm_medium=link&#x26;utm_campaign=storybook\">chromatic.com</a> y regÃ­strese con su cuenta de GitHub.</p>\n<p><img src=\"/tutorials/visual-testing-handbook/chromatic-sign-in-optimized.png\" alt=\"Inicio de sesiÃ³n de Chromatic\"></p>\n<p>Desde allÃ­, elija el repositorio que acaba de crear.</p>\n<video autoPlay muted playsInline loop>\n  <source src=\"/tutorials/visual-testing-handbook/chromatic-create-project-optimized.mp4\"\n    type=\"video/mp4\" />\n</video>\n<p>Las pruebas de interfaz de usuario capturan una instantÃ¡nea de cada historia en un entorno de navegador en la nube. Siempre que envÃ­e cÃ³digo, Chromatic genera un nuevo conjunto de instantÃ¡neas y las compara con las lÃ­neas base. Si hay cambios visuales, verifica si son intencionales.</p>\n<h3>Establezca lÃ­neas base</h3>\n<p>Agregue Chromatic como paquete de desarrollo a su proyecto:</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`yarn add -D chromatic`, `40659094857750364000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"40659094857750364000\"\n              >\n                Copy \n              </div>\n            </div>\n<pre><code class=\"language-shell\">yarn add -D chromatic\n</code></pre>\n<p>Una vez que termine de instalarse, tendremos todo lo que necesitamos. Ahora es un excelente momento para confirmar y enviar los cambios al repositorio remoto.</p>\n<pre><code class=\"language-shell\">git add .\ngit commit -m \"Added Chromatic\"\ngit push\n</code></pre>\n<p>Construya y publique nuestro Storybook con el comando <code>chromatic</code>. No olvide reemplazar el <code> project-token </code> con un suministro de Chromatic en el sitio web.</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`yarn chromatic --project-token=<project-token>`, `40466963465643620000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"40466963465643620000\"\n              >\n                Copy \n              </div>\n            </div>\n<pre><code class=\"language-shell\">yarn chromatic --project-token=&#x3C;project-token>\n</code></pre>\n<p><img src=\"/tutorials/intro-to-storybook/chromatic-manual-storybook-console-log.png\" alt=\"Ejecutando Chromatic\"></p>\n<p>Con este comando, usted publicÃ³ su Storybook, activÃ³ Chromatic para capturar una instantÃ¡nea de cada historia (en un navegador en la nube estandarizado) y estableciÃ³ la instantÃ¡nea como lÃ­nea base.</p>\n<p>Las compilaciones posteriores generarÃ¡n nuevas instantÃ¡neas que se comparan con las lÃ­neas base existentes para detectar cambios en la interfaz de usuario.</p>\n<p><img src=\"/tutorials/visual-testing-handbook/commentlist-accepted-baselines-optimized.png\" alt=\"LÃ­neas base en Chromatic\"></p>\n<h3>Ejecute las pruebas</h3>\n<p>Cada vez que una pull request contiene cambios en la interfaz de usuario, grandes o pequeÃ±os, es Ãºtil ejecutar las pruebas visuales. Chromatic compara nuevas instantÃ¡neas con lÃ­neas base existentes de compilaciones anteriores.</p>\n<p>Hagamos un pequeÃ±o cambio en la interfaz de usuario para demostrar este concepto.</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`git checkout -b change-commentlist-outline`, `4298031542373426000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"4298031542373426000\"\n              >\n                Copy \n              </div>\n            </div>\n<pre><code class=\"language-shell\">git checkout -b change-commentlist-outline\n</code></pre>\n<p>Ajuste el componente <code>CommentList</code></p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`import React from 'react';\n\nimport PropTypes from 'prop-types';\nimport styled, { createGlobalStyle } from 'styled-components';\n\nconst CommentListDiv = styled.div\\`\n  font-family: &quot;Nunito Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif;\n  color: #333;\n  display: inline-block;\n  vertical-align: top;\n  width: 265px;\n\\`;\n\nconst CommentItemDiv = styled.div\\`\n  font-size: 12px;\n  line-height: 14px;\n  clear: both;\n  height: 48px;\n  margin-bottom: 10px;\n  box-shadow: rgba(0, 0, 0, 0.2) 0 0 10px 0;\n  background: linear-gradient(\n    120deg,\n    rgba(248, 248, 254, 0.95),\n    rgba(250, 250, 250, 0.95)\n  );\n  border-radius: 48px;\n border: 4px solid red;\n font-weight: bold;\n\\`;\n\nconst AvatarDiv = styled.div\\`\n  float: left;\n  position: relative;\n  overflow: hidden;\n  height: 48px;\n  width: 48px;\n  margin-right: 14px;\n  background: #dfecf2;\n  border-radius: 48px;\n\\`;\n\nconst AvatarImg = styled.img\\`\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  left: 0;\n  top: 0;\n  z-index: 1;\n  background: #999;\n\\`;\n\nconst MessageDiv = styled.div\\`\n  overflow: hidden;\n  padding-top: 10px;\n  padding-right: 20px;\n\\`;\n\nconst AuthorSpan = styled.span\\`\n  font-weight: bold;\n\\`;\nconst TextSpan = styled.span\\`\\`;\n\nconst GlobalStyle = createGlobalStyle\\`\n@import url('https://fonts.googleapis.com/css?family=Nunito+Sans:400,400i,800');\n\\`;\n\nexport default function CommentList({ loading, comments, totalCount }) {\n  if (loading) {\n    return <div>loading</div>;\n  }\n  if (comments.length === 0) {\n    return <div>empty</div>;\n  }\n  return (\n    <>\n    <GlobalStyle/>\n    <CommentListDiv>\n      {comments.map(({ text, author: { name, avatar } }) => (\n        <CommentItemDiv key={\\`comment_\\${name}\\`}>\n          <AvatarDiv>\n            <AvatarImg src={avatar} />\n          </AvatarDiv>\n          <MessageDiv>\n            <AuthorSpan>{name}</AuthorSpan> <TextSpan>{text}</TextSpan>\n          </MessageDiv>\n        </CommentItemDiv>\n      ))}\n    </CommentListDiv>\n    </>\n  );\n}\n\nCommentList.propTypes = {\n  /**\n   * Is the component in the loading state\n   */\n  loading: PropTypes.bool,\n\n  /**\n   * Total number of comments\n   */\n  totalCount: PropTypes.number,\n  /**\n   * List of comments\n   */\n  comments: PropTypes.arrayOf(\n    PropTypes.shape({\n      text: PropTypes.string,\n      author: PropTypes.shape({\n        name: PropTypes.string,\n        avatar: PropTypes.string,\n      }),\n    })\n  ),\n};\n\nCommentList.defaultProps = {\n  loading: false,\n  totalCount: 10,\n  comments: [],\n};\n`, `20369867642330886000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"20369867642330886000\"\n              >\n                Copy \n              </div>\n            </div>\n<div class=\"gatsby-code-title\">src/components/CommentList.js</div>\n<pre><code class=\"language-diff\">import React from 'react';\n\nimport PropTypes from 'prop-types';\nimport styled, { createGlobalStyle } from 'styled-components';\n\nconst CommentListDiv = styled.div`\n  font-family: \"Nunito Sans\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n  color: #333;\n  display: inline-block;\n  vertical-align: top;\n  width: 265px;\n`;\n\nconst CommentItemDiv = styled.div`\n  font-size: 12px;\n  line-height: 14px;\n  clear: both;\n  height: 48px;\n  margin-bottom: 10px;\n  box-shadow: rgba(0, 0, 0, 0.2) 0 0 10px 0;\n  background: linear-gradient(\n    120deg,\n    rgba(248, 248, 254, 0.95),\n    rgba(250, 250, 250, 0.95)\n  );\n  border-radius: 48px;\n+ border: 4px solid red;\n+ font-weight: bold;\n`;\n\nconst AvatarDiv = styled.div`\n  float: left;\n  position: relative;\n  overflow: hidden;\n  height: 48px;\n  width: 48px;\n  margin-right: 14px;\n  background: #dfecf2;\n  border-radius: 48px;\n`;\n\nconst AvatarImg = styled.img`\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  left: 0;\n  top: 0;\n  z-index: 1;\n  background: #999;\n`;\n\nconst MessageDiv = styled.div`\n  overflow: hidden;\n  padding-top: 10px;\n  padding-right: 20px;\n`;\n\nconst AuthorSpan = styled.span`\n  font-weight: bold;\n`;\nconst TextSpan = styled.span``;\n\nconst GlobalStyle = createGlobalStyle`\n@import url('https://fonts.googleapis.com/css?family=Nunito+Sans:400,400i,800');\n`;\n\nexport default function CommentList({ loading, comments, totalCount }) {\n  if (loading) {\n    return &#x3C;div>loading&#x3C;/div>;\n  }\n  if (comments.length === 0) {\n    return &#x3C;div>empty&#x3C;/div>;\n  }\n  return (\n    &#x3C;>\n    &#x3C;GlobalStyle/>\n    &#x3C;CommentListDiv>\n      {comments.map(({ text, author: { name, avatar } }) => (\n        &#x3C;CommentItemDiv key={`comment_${name}`}>\n          &#x3C;AvatarDiv>\n            &#x3C;AvatarImg src={avatar} />\n          &#x3C;/AvatarDiv>\n          &#x3C;MessageDiv>\n            &#x3C;AuthorSpan>{name}&#x3C;/AuthorSpan> &#x3C;TextSpan>{text}&#x3C;/TextSpan>\n          &#x3C;/MessageDiv>\n        &#x3C;/CommentItemDiv>\n      ))}\n    &#x3C;/CommentListDiv>\n    &#x3C;/>\n  );\n}\n\nCommentList.propTypes = {\n  /**\n   * Is the component in the loading state\n   */\n  loading: PropTypes.bool,\n\n  /**\n   * Total number of comments\n   */\n  totalCount: PropTypes.number,\n  /**\n   * List of comments\n   */\n  comments: PropTypes.arrayOf(\n    PropTypes.shape({\n      text: PropTypes.string,\n      author: PropTypes.shape({\n        name: PropTypes.string,\n        avatar: PropTypes.string,\n      }),\n    })\n  ),\n};\n\nCommentList.defaultProps = {\n  loading: false,\n  totalCount: 10,\n  comments: [],\n};\n\n</code></pre>\n<p>Confirme el cambio, envÃ­elo al repositorio y ejecute Chromatic:</p>\n<pre><code class=\"language-shell\">git commit -am \"make CommentList sparkle\"\ngit push -u origin change-commentlist-outline\nyarn chromatic --project-token=&#x3C;project-token>\n</code></pre>\n<p>Abra una pull request para la nueva rama en su repositorio de GitHub.</p>\n<p><img src=\"/tutorials/visual-testing-handbook/commentlist-gh-pullrequest-optimized.png\" alt=\"Comment list pull requested abierta en GitHub\"></p>\n<p>Chromatic detectÃ³ cambios en la interfaz de usuario para que los revises. Vaya a las verificaciones de la PR y haga clic en \"ğŸŸ¡ UI Test\" para ver la lista de cambios. La compilaciÃ³n se marcarÃ¡ como â€œunreviewedâ€, o â€œno revisadaâ€, y los cambios se enumerarÃ¡n en la tabla â€œTestsâ€.</p>\n<p><img src=\"/tutorials/visual-testing-handbook/commentlist-ui-tests-chromatic-optimized.png\" alt=\"Nuevos cambios publicados en Chromatic\"></p>\n<h3>Revise los cambios</h3>\n<p>La automatizaciÃ³n de las pruebas visuales garantiza que los componentes no cambien por accidente. Pero aÃºn depende de los desarrolladores determinar si los cambios son intencionales o no.</p>\n<p>Si un cambio es intencional, aceptamos la instantÃ¡nea para actualizar la lÃ­nea base. Eso significa que las pruebas futuras se compararÃ¡n con el componente <code>CommentList</code> con bordes rojos.</p>\n<p>Si un cambio no es intencional, es necesario corregirlo. Nuestro diseÃ±ador cree que el âœ¨majestuosoâœ¨ borde rojo es horripilante, asÃ­ que deshagÃ¡moslo.</p>\n<p><img src=\"/tutorials/visual-testing-handbook/chromatic-test-screen-optimized.png\" alt=\"Chromatic pantalla de prueba\"></p>\n<h3>Fusionar los cambios</h3>\n<p>Una vez que los errores se corrijan y las lÃ­neas base estÃ©n actualizadas, estÃ¡s listo para fusionar el cÃ³digo nuevamente en la rama de destino. Chromatic transferirÃ¡ las lÃ­neas base aceptadas entre las ramas para que solo tenga que aceptar las lÃ­neas base una vez.</p>\n<p><img src=\"/tutorials/visual-testing-handbook/workflow-uitest.png\" alt=\"flujo de trabajo de las pruebas visuales\"></p>\n<h3>IntegraciÃ³n continua</h3>\n<p>Ejecutar este comando localmente cada vez que hacemos un cambio es tedioso. Los equipos de producciÃ³n activan ejecuciones de pruebas visuales cuando se inserta el cÃ³digo en su CI/CD pipeline. Si bien no lo configuraremos en este tutorial, puede obtener mÃ¡s informaciÃ³n en <a href=\"https://www.chromatic.com/docs/ci?utm_source=storybook_website&#x26;utm_medium=link&#x26;utm_campaign=storybook\">Chromatic's CI docs</a>.</p>\n<h2>Su viaje comienza</h2>\n<p>El manual de pruebas visuales muestra cÃ³mo los equipos de frontend lÃ­deres prueban la apariencia de la interfaz de usuario. Es una forma prÃ¡ctica de verificar que la interfaz de usuario coincide con el diseÃ±o previsto y permanece libre de errores con el tiempo.</p>\n<p>Esperamos que esta guÃ­a inspire su propia estrategia de prueba visual. El capÃ­tulo final concluye con el cÃ³digo de muestra completo y recursos Ãºtiles.</p>","frontmatter":{"title":"Automatizar las pruebas visuales","description":"Automatice las pruebas visuales para detectar regresiones","commit":"2c4f211"},"fields":{"guide":"visual-testing-handbook","slug":"/visual-testing-handbook/react/es/automate/","chapter":"automate","framework":"react","language":"es","permalink":"https://storybook.js.org/tutorials/visual-testing-handbook/react/es/automate/","tutorialUpToDate":false}},"currentGuide":{"frontmatter":{"codeGithubUrl":"https://github.com/chromaui/learnstorybook-visual-testing-code","toc":["introduction","component-explorers","workflow","vtdd","automate","conclusion"],"title":"Visual Testing Handbook","twitterShareText":"Iâ€™m learning how to visual test UIs with Storybook! Itâ€™s great for finding UI bugs automatically."}},"site":{"siteMetadata":{"title":"Storybook Tutorials","githubUrl":"https://github.com/chromaui/learnstorybook.com","contributeUrl":"https://github.com/chromaui/learnstorybook.com/#contribute","permalink":"https://storybook.js.org/tutorials","siteUrl":"https://storybook.js.org"}},"tocPages":{"edges":[{"node":{"frontmatter":{"tocTitle":"Automatizar","title":"Automatizar las pruebas visuales","description":"Automatice las pruebas visuales para detectar regresiones"},"fields":{"slug":"/visual-testing-handbook/react/es/automate/","framework":"react","chapter":"automate"}}},{"node":{"frontmatter":{"tocTitle":"Exploradores de componentes","title":"Exploradores de componentes","description":"Una herramienta para el desarrollo de la UI y las pruebas visuales"},"fields":{"slug":"/visual-testing-handbook/react/es/component-explorers/","framework":"react","chapter":"component-explorers"}}},{"node":{"frontmatter":{"tocTitle":"ConclusiÃ³n","title":"ConclusiÃ³n","description":"Di adiÃ³s a los errores visuales"},"fields":{"slug":"/visual-testing-handbook/react/es/conclusion/","framework":"react","chapter":"conclusion"}}},{"node":{"frontmatter":{"tocTitle":"IntroducciÃ³n","title":"IntroducciÃ³n a las pruebas visuales","description":"La manera pragmÃ¡tica de probar interfaces de usuario"},"fields":{"slug":"/visual-testing-handbook/react/es/introduction/","framework":"react","chapter":"introduction"}}},{"node":{"frontmatter":{"tocTitle":null,"title":"TDD Visual","description":"Escribe tus primeras pruebas visuales"},"fields":{"slug":"/visual-testing-handbook/react/es/vtdd/","framework":"react","chapter":"vtdd"}}},{"node":{"frontmatter":{"tocTitle":null,"title":"Flujo de trabajo","description":"Un flujo de trabajo guiado por pruebas para la construcciÃ³n de componentes"},"fields":{"slug":"/visual-testing-handbook/react/es/workflow/","framework":"react","chapter":"workflow"}}}]},"translationPages":{"edges":[{"node":{"frontmatter":{"tocTitle":"Automate","title":"Automate visual testing","description":"Automate visual testing to catch regressions"},"fields":{"slug":"/visual-testing-handbook/react/en/automate/","framework":"react","chapter":"automate","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Component explorers","title":"Component explorers","description":"A tool for UI development and visual testing"},"fields":{"slug":"/visual-testing-handbook/react/en/component-explorers/","framework":"react","chapter":"component-explorers","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Conclusion","title":"Conclusion","description":"Say bye to visual bugs"},"fields":{"slug":"/visual-testing-handbook/react/en/conclusion/","framework":"react","chapter":"conclusion","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Introduction","title":"Introduction to visual testing","description":"The pragmatic way to test user interfaces"},"fields":{"slug":"/visual-testing-handbook/react/en/introduction/","framework":"react","chapter":"introduction","language":"en"}}},{"node":{"frontmatter":{"tocTitle":null,"title":"Visual TDD","description":"Write your first visual tests"},"fields":{"slug":"/visual-testing-handbook/react/en/vtdd/","framework":"react","chapter":"vtdd","language":"en"}}},{"node":{"frontmatter":{"tocTitle":null,"title":"Workflow","description":"A test-driven workflow for building components"},"fields":{"slug":"/visual-testing-handbook/react/en/workflow/","framework":"react","chapter":"workflow","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Automatizar","title":"Automatizar las pruebas visuales","description":"Automatice las pruebas visuales para detectar regresiones"},"fields":{"slug":"/visual-testing-handbook/react/es/automate/","framework":"react","chapter":"automate","language":"es"}}},{"node":{"frontmatter":{"tocTitle":"Exploradores de componentes","title":"Exploradores de componentes","description":"Una herramienta para el desarrollo de la UI y las pruebas visuales"},"fields":{"slug":"/visual-testing-handbook/react/es/component-explorers/","framework":"react","chapter":"component-explorers","language":"es"}}},{"node":{"frontmatter":{"tocTitle":"ConclusiÃ³n","title":"ConclusiÃ³n","description":"Di adiÃ³s a los errores visuales"},"fields":{"slug":"/visual-testing-handbook/react/es/conclusion/","framework":"react","chapter":"conclusion","language":"es"}}},{"node":{"frontmatter":{"tocTitle":"IntroducciÃ³n","title":"IntroducciÃ³n a las pruebas visuales","description":"La manera pragmÃ¡tica de probar interfaces de usuario"},"fields":{"slug":"/visual-testing-handbook/react/es/introduction/","framework":"react","chapter":"introduction","language":"es"}}},{"node":{"frontmatter":{"tocTitle":null,"title":"TDD Visual","description":"Escribe tus primeras pruebas visuales"},"fields":{"slug":"/visual-testing-handbook/react/es/vtdd/","framework":"react","chapter":"vtdd","language":"es"}}},{"node":{"frontmatter":{"tocTitle":null,"title":"Flujo de trabajo","description":"Un flujo de trabajo guiado por pruebas para la construcciÃ³n de componentes"},"fields":{"slug":"/visual-testing-handbook/react/es/workflow/","framework":"react","chapter":"workflow","language":"es"}}},{"node":{"frontmatter":{"tocTitle":"ìë™í™”","title":"ì‹œê°ì  í…ŒìŠ¤íŠ¸ ìë™í™”","description":"íšŒê·€ ì˜¤ë¥˜ë¥¼ ì¡ê¸° ìœ„í•´ ì‹œê°ì  í…ŒìŠ¤íŠ¸ë¥¼ ìë™í™”í•˜ê¸°"},"fields":{"slug":"/visual-testing-handbook/react/ko/automate/","framework":"react","chapter":"automate","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"ì»´í¬ë„ŒíŠ¸ íƒìƒ‰ê¸°","title":"ì»´í¬ë„ŒíŠ¸ íƒìƒ‰ê¸°","description":"UI ê°œë°œê³¼ ì‹œê°ì  í…ŒìŠ¤íŒ…ì„ ìœ„í•œ ë„êµ¬"},"fields":{"slug":"/visual-testing-handbook/react/ko/component-explorer/","framework":"react","chapter":"component-explorer","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"ë§ˆë¬´ë¦¬","title":"ë§ˆë¬´ë¦¬","description":"ì‹œê°ì  ë²„ê·¸ë“¤ì— ì•ˆë…•ì„"},"fields":{"slug":"/visual-testing-handbook/react/ko/conclusion/","framework":"react","chapter":"conclusion","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"ì†Œê°œ","title":"ì‹œê°ì  í…ŒìŠ¤íŒ… ì†Œê°œ","description":"UIë¥¼ í…ŒìŠ¤íŠ¸í•˜ëŠ” ì‹¤ìš©ì ì¸ ë°©ë²•"},"fields":{"slug":"/visual-testing-handbook/react/ko/introduction/","framework":"react","chapter":"introduction","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":null,"title":"ì‹œê°ì  TDD","description":"ì²« ë²ˆì§¸ ì‹œê°ì  í…ŒìŠ¤íŠ¸ë¥¼ ë§Œë“¤ì–´ë³´ì„¸ìš”"},"fields":{"slug":"/visual-testing-handbook/react/ko/vtdd/","framework":"react","chapter":"vtdd","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":null,"title":"ì‘ì—… íë¦„(Work Flow)","description":"ì»´í¬ë„ŒíŠ¸ ì„¤ê³„ë¥¼ ìœ„í•œ í…ŒìŠ¤íŠ¸ ì£¼ë„(test-driven) ì‘ì—… íë¦„(workflow)"},"fields":{"slug":"/visual-testing-handbook/react/ko/workflow/","framework":"react","chapter":"workflow","language":"ko"}}}]}},"pageContext":{"guide":"visual-testing-handbook","slug":"/visual-testing-handbook/react/es/automate/","framework":"react","language":"es","chapter":"automate","pageType":"chapter"}},"staticQueryHashes":["238248339"]}