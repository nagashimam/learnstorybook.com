{"componentChunkName":"component---src-components-screens-chapter-screen-index-js","path":"/visual-testing-handbook/react/ko/automate/","result":{"data":{"currentPage":{"html":"<p>자연스러운 개발 과정에서 버그(bug)가 생기는 것을 막을 수는 없습니다. 시각적 테스트 자동화는 기계를 사용해 사용자가 검토할 UI 외관의 변화를 감지합니다.</p>\n<p>핵심만 말하자면, 각 컴포넌트의 변화형(variation)마다 이미지 스냅샷을 찍습니다. 이는 시각적 테스트의 '기준선(baseline)'으로 쓰입니다. 각 commit마다, 새 스냅샷을 찍고, 이 기준선과 픽셀 하나하나를 비교합니다. 혹시 UI에 변한 부분이 있으면, 버그인지 의도적인 변경인지 검토해달라고 알림을 받습니다.</p>\n<video autoPlay muted playsInline loop >\n  <source\n    src=\"/tutorials/visual-testing-handbook/automate-visual-workflow-test-diff.mp4\"\n    type=\"video/mp4\"\n  />\n</video>\n<h2>깃허브(Github) 저장소를 구축하기</h2>\n<p>시작하기 전에, 로컬 <code>CommentList</code> 코드가 원격 버전 관리 서비스와 동기화되어야 합니다.</p>\n<p>깃허브에 접속하여 프로젝트 <a href=\"https://github.com/new\">여기</a>)의 새로운 저장소를 만듭니다. 지역 프로젝트와 마찬가지로 저장소(repo)의 이름을 \"commentlist\"로 지정합니다.</p>\n<p><img src=\"/tutorials/visual-testing-handbook/commentlist-gh-repo-optimized.png\" alt=\"깃허브에서 댓글 목록 저장소(repo) 설정\"></p>\n<p>그런 다음 지침에 따라 저장소를 설정합니다. <code>your-username</code>을 깃허브 계정명으로 바꿉니다.</p>\n<pre><code class=\"language-shell\">git init\ngit add .\ngit commit -m \"first commit\"\ngit branch -M main\ngit remote add origin https://github.com/your-username/commentlist.git\ngit push -u origin main\n</code></pre>\n<h2>크로마틱(Chromatic) 설정</h2>\n<p>Chromatic by Storybook maintainers를 사용하여 이미지 스냅샷 프로세스를 시연합니다. <a href=\"https://www.chromatic.com/?utm_source=storybook_website&#x26;utm_medium=link&#x26;utm_campaign=storybook\">chromatic.com</a>)에 접속하여 깃허브 계정으로 가입하세요.</p>\n<p><img src=\"/tutorials/visual-testing-handbook/chromatic-sign-in-optimized.png\" alt=\"크로마틱 로그인\"></p>\n<p>여기서 방금 만든 저장소를 선택합니다.</p>\n<video autoPlay muted playsInline loop>\n  <source src=\"/tutorials/visual-testing-handbook/chromatic-create-project-optimized.mp4\"\n    type=\"video/mp4\" />\n</video>\n<p>UI 테스트는 클라우드 브라우저 환경의 모든 스토리의 이미지 스냅샷을 캡처합니다. 코드를 push할 때마다 크로마틱은 새 스냅샷 집합을 생성하여 기준선과 비교합니다. 시각적 변화가 있는 경우 의도적인 것인지 확인합니다.</p>\n<h3>기준선 설정</h3>\n<p>프로젝트에 개발 패키지로 크로마틱을 추가합니다 -</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`yarn add -D chromatic`, `54947190678361050000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"54947190678361050000\"\n              >\n                Copy \n              </div>\n            </div>\n<pre><code class=\"language-shell\">yarn add -D chromatic\n</code></pre>\n<p>설치가 완료되면 필요한 모든 것을 얻을 수 있습니다. 지금이야말로 변경을 리모트 저장소로 commit하고 push할 절호의 기회입니다.</p>\n<pre><code class=\"language-shell\">git add .\ngit commit -m \"Added Chromatic\"\ngit push\n</code></pre>\n<p>크로마틱 명령어로 스토리북을 제작하여 퍼블리싱하세요. 웹사이트에서 <code> project-token </code>를 하나의 크로마틱 공급 장치로 교체하는 것을 잊지 마세요.</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`yarn chromatic --project-token=<project-token>`, `59107437945830244000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"59107437945830244000\"\n              >\n                Copy \n              </div>\n            </div>\n<pre><code class=\"language-shell\">yarn chromatic --project-token=&#x3C;project-token>\n</code></pre>\n<p><img src=\"/tutorials/intro-to-storybook/chromatic-manual-storybook-console-log.png\" alt=\"크로마틱 실행\"></p>\n<p>이 명령어 하나로 스토리북을 퍼블리싱하고 크로매틱이 각 스토리(story)(표준 클라우드 브라우저에서)의 이미지 스냅샷을 캡처하고 스냅샷을 기준으로 설정하도록 했습니다.</p>\n<p>이후 빌드(build)는 UI 변경을 감지하기 위해 기존 기준선과 비교되는 새 스냅샷을 생성합니다.</p>\n<p><img src=\"/tutorials/visual-testing-handbook/commentlist-accepted-baselines-optimized.png\" alt=\"크로마틱의 기준선\"></p>\n<h3>테스트를 실행하기</h3>\n<p>풀 리퀘스트(PR)가 UI 변경을 포함하고 있다면, 크던 작던, 시각적 테스트를 실행하는 게 유용합니다. 크로마틱은 새 스냅샷들을 이전 빌드에서 만들었던 기존의 기준선과 비교할 겁니다.</p>\n<p>그럼 이 개념을 설명하기 위해 UI를 약간 변경해 보겠습니다.</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`git checkout -b change-commentlist-outline`, `82410762133471920000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"82410762133471920000\"\n              >\n                Copy \n              </div>\n            </div>\n<pre><code class=\"language-shell\">git checkout -b change-commentlist-outline\n</code></pre>\n<p><code>CommentList</code> 컴포넌트를 약간 뒤틀어봅니다.</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`import React from 'react';\n\nimport PropTypes from 'prop-types';\nimport styled, { createGlobalStyle } from 'styled-components';\n\nconst CommentListDiv = styled.div\\`\n  font-family: &quot;Nunito Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif;\n  color: #333;\n  display: inline-block;\n  vertical-align: top;\n  width: 265px;\n\\`;\n\nconst CommentItemDiv = styled.div\\`\n  font-size: 12px;\n  line-height: 14px;\n  clear: both;\n  height: 48px;\n  margin-bottom: 10px;\n  box-shadow: rgba(0, 0, 0, 0.2) 0 0 10px 0;\n  background: linear-gradient(\n    120deg,\n    rgba(248, 248, 254, 0.95),\n    rgba(250, 250, 250, 0.95)\n  );\n  border-radius: 48px;\n border: 4px solid red;\n font-weight: bold;\n\\`;\n\nconst AvatarDiv = styled.div\\`\n  float: left;\n  position: relative;\n  overflow: hidden;\n  height: 48px;\n  width: 48px;\n  margin-right: 14px;\n  background: #dfecf2;\n  border-radius: 48px;\n\\`;\n\nconst AvatarImg = styled.img\\`\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  left: 0;\n  top: 0;\n  z-index: 1;\n  background: #999;\n\\`;\n\nconst MessageDiv = styled.div\\`\n  overflow: hidden;\n  padding-top: 10px;\n  padding-right: 20px;\n\\`;\n\nconst AuthorSpan = styled.span\\`\n  font-weight: bold;\n\\`;\nconst TextSpan = styled.span\\`\\`;\n\nconst GlobalStyle = createGlobalStyle\\`\n@import url('https://fonts.googleapis.com/css?family=Nunito+Sans:400,400i,800');\n\\`;\n\nexport default function CommentList({ loading, comments, totalCount }) {\n  if (loading) {\n    return <div>loading</div>;\n  }\n  if (comments.length === 0) {\n    return <div>empty</div>;\n  }\n  return (\n    <>\n    <GlobalStyle/>\n    <CommentListDiv>\n      {comments.map(({ text, author: { name, avatar } }) => (\n        <CommentItemDiv key={\\`comment_\\${name}\\`}>\n          <AvatarDiv>\n            <AvatarImg src={avatar} />\n          </AvatarDiv>\n          <MessageDiv>\n            <AuthorSpan>{name}</AuthorSpan> <TextSpan>{text}</TextSpan>\n          </MessageDiv>\n        </CommentItemDiv>\n      ))}\n    </CommentListDiv>\n    </>\n  );\n}\n\nCommentList.propTypes = {\n  /**\n   * Is the component in the loading state\n   */\n  loading: PropTypes.bool,\n\n  /**\n   * Total number of comments\n   */\n  totalCount: PropTypes.number,\n  /**\n   * List of comments\n   */\n  comments: PropTypes.arrayOf(\n    PropTypes.shape({\n      text: PropTypes.string,\n      author: PropTypes.shape({\n        name: PropTypes.string,\n        avatar: PropTypes.string,\n      }),\n    })\n  ),\n};\n\nCommentList.defaultProps = {\n  loading: false,\n  totalCount: 10,\n  comments: [],\n};\n`, `48306694534123190000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"48306694534123190000\"\n              >\n                Copy \n              </div>\n            </div>\n<div class=\"gatsby-code-title\">src/components/CommentList.js</div>\n<pre><code class=\"language-diff\">import React from 'react';\n\nimport PropTypes from 'prop-types';\nimport styled, { createGlobalStyle } from 'styled-components';\n\nconst CommentListDiv = styled.div`\n  font-family: \"Nunito Sans\", \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n  color: #333;\n  display: inline-block;\n  vertical-align: top;\n  width: 265px;\n`;\n\nconst CommentItemDiv = styled.div`\n  font-size: 12px;\n  line-height: 14px;\n  clear: both;\n  height: 48px;\n  margin-bottom: 10px;\n  box-shadow: rgba(0, 0, 0, 0.2) 0 0 10px 0;\n  background: linear-gradient(\n    120deg,\n    rgba(248, 248, 254, 0.95),\n    rgba(250, 250, 250, 0.95)\n  );\n  border-radius: 48px;\n+ border: 4px solid red;\n+ font-weight: bold;\n`;\n\nconst AvatarDiv = styled.div`\n  float: left;\n  position: relative;\n  overflow: hidden;\n  height: 48px;\n  width: 48px;\n  margin-right: 14px;\n  background: #dfecf2;\n  border-radius: 48px;\n`;\n\nconst AvatarImg = styled.img`\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  left: 0;\n  top: 0;\n  z-index: 1;\n  background: #999;\n`;\n\nconst MessageDiv = styled.div`\n  overflow: hidden;\n  padding-top: 10px;\n  padding-right: 20px;\n`;\n\nconst AuthorSpan = styled.span`\n  font-weight: bold;\n`;\nconst TextSpan = styled.span``;\n\nconst GlobalStyle = createGlobalStyle`\n@import url('https://fonts.googleapis.com/css?family=Nunito+Sans:400,400i,800');\n`;\n\nexport default function CommentList({ loading, comments, totalCount }) {\n  if (loading) {\n    return &#x3C;div>loading&#x3C;/div>;\n  }\n  if (comments.length === 0) {\n    return &#x3C;div>empty&#x3C;/div>;\n  }\n  return (\n    &#x3C;>\n    &#x3C;GlobalStyle/>\n    &#x3C;CommentListDiv>\n      {comments.map(({ text, author: { name, avatar } }) => (\n        &#x3C;CommentItemDiv key={`comment_${name}`}>\n          &#x3C;AvatarDiv>\n            &#x3C;AvatarImg src={avatar} />\n          &#x3C;/AvatarDiv>\n          &#x3C;MessageDiv>\n            &#x3C;AuthorSpan>{name}&#x3C;/AuthorSpan> &#x3C;TextSpan>{text}&#x3C;/TextSpan>\n          &#x3C;/MessageDiv>\n        &#x3C;/CommentItemDiv>\n      ))}\n    &#x3C;/CommentListDiv>\n    &#x3C;/>\n  );\n}\n\nCommentList.propTypes = {\n  /**\n   * Is the component in the loading state\n   */\n  loading: PropTypes.bool,\n\n  /**\n   * Total number of comments\n   */\n  totalCount: PropTypes.number,\n  /**\n   * List of comments\n   */\n  comments: PropTypes.arrayOf(\n    PropTypes.shape({\n      text: PropTypes.string,\n      author: PropTypes.shape({\n        name: PropTypes.string,\n        avatar: PropTypes.string,\n      }),\n    })\n  ),\n};\n\nCommentList.defaultProps = {\n  loading: false,\n  totalCount: 10,\n  comments: [],\n};\n\n</code></pre>\n<p>변경사항을 commit하고, 저장소에 push한 뒤에 크로마틱을 실행합니다.</p>\n<div\n              class=\"gatsby-code-button-container\"\n              onClick=\"copyToClipboard(`git commit -am &quot;make CommentList sparkle&quot;\ngit push -u origin change-commentlist-outline\nyarn chromatic --project-token=<project-token>`, `59998144991328120000`)\"\n            >\n              <div\n                class=\"gatsby-code-button\"\n                data-toaster-id=\"59998144991328120000\"\n              >\n                Copy \n              </div>\n            </div>\n<pre><code class=\"language-shell\">git commit -am \"make CommentList sparkle\"\ngit push -u origin change-commentlist-outline\nyarn chromatic --project-token=&#x3C;project-token>\n</code></pre>\n<p>깃허브 저장소에서 새 브랜치를 위한 풀 리퀘스트를 엽니다.</p>\n<p><img src=\"/tutorials/visual-testing-handbook/commentlist-gh-pullrequest-optimized.png\" alt=\"깃허브에서 열린 CommentList 풀 리퀘스트(PR)\"></p>\n<p>사용자가 검토할 UI 변경 사항을 크로마틱으로 감지했습니다! 변경 사항 목록을 보려면 PR checks로 가서 \"🟡 UI Test\"를 클릭하세요. 이번 빌드는 \"unreviewed\"라고 표시되고 변경 사항들은 \"Tests\" 테이블에 나열됩니다.</p>\n<p><img src=\"/tutorials/visual-testing-handbook/commentlist-ui-tests-chromatic-optimized.png\" alt=\"크로마틱에 발행된 새 변경 사항들\">Chromatic</p>\n<h3>변경 내용 확인</h3>\n<p>시각 테스트를 자동화하여 컴포넌트가 실수로 변경되지 않도록 합니다. 그러나 변경이 의도적인 것인지 아닌지 결정 여부는 여전히 개발자들에게 달려 있습니다.</p>\n<p>의도적으로 변경한 경우에는 스냅샷을 받아들여 기준선을 업데이트합니다.따라서 미래의 테스트는 빨간 테두리를 두른 <code>CommentList</code>를 기준으로 비교하게 됩니다.</p>\n<p>의도하지 않은 변경이라면 고쳐야 합니다. 우리 디자이너는 이 ✨장엄한✨ 빨간 테두리가 끔찍하다고 생각하니 변경을 취소하겠습니다.</p>\n<p><img src=\"/tutorials/visual-testing-handbook/chromatic-test-screen-optimized.png\" alt=\"크로마틱 테스트 화면\"></p>\n<h3>변경 사항을 merge하기</h3>\n<p>버그가 수정되고 기준선이 최신 상태가 되면, 코드를 target 브랜치로 다시 merge할 수 있습니다. 크로마틱은 브랜치 사이에서 승인된 기준선을 전송하므로 기준선을 한 번만 승인해주면 됩니다.</p>\n<p><img src=\"/tutorials/visual-testing-handbook/workflow-uitest.png\" alt=\"시각적 테스팅 작업 흐름(workflow)\"></p>\n<h3>지속적 통합</h3>\n<p>변경사항을 만들 때마다 이 명령어를 로컬에서 실행하는 건 귀찮습니다. 프로덕션 팀은 코드를 CI/CD 파이프라인에 push할 때마다 시각적 테스트가 실행되게 트리거(trigger)를 설정합니다. 이 튜토리얼에서는 설정하지 않지만<a href=\"https://www.chromatic.com/docs/ci?utm_source=storybook_website&#x26;utm_medium=link&#x26;utm_campaign=storybook\">크로마틱의 CI docs</a>에서 자세한 내용을 확인할 수 있습니다.</p>\n<h2>여정의 시작</h2>\n<p>시각적 테스팅 핸드북은 주요 프런트엔드 팀이 UI 외관을 테스트하는 방법을 보여주는 쇼케이스였습니다. 시각적 테스팅은 UI가 의도한 설계와 일치하고 시간이 지남에 따라 버그가 발생하지 않는지 확인하는 실용적인 방법입니다.</p>\n<p>이 가이드가 당신의 시각적 테스트 전략에 도움이 되기를 바랍니다. 마지막 장에서는 완전한 샘플 코드와 유용한 자료들 소개로 마무리하겠습니다.</p>","frontmatter":{"title":"시각적 테스트 자동화","description":"회귀 오류를 잡기 위해 시각적 테스트를 자동화하기","commit":"2c4f211"},"fields":{"guide":"visual-testing-handbook","slug":"/visual-testing-handbook/react/ko/automate/","chapter":"automate","framework":"react","language":"ko","permalink":"https://storybook.js.org/tutorials/visual-testing-handbook/react/ko/automate/","tutorialUpToDate":false}},"currentGuide":{"frontmatter":{"codeGithubUrl":"https://github.com/chromaui/learnstorybook-visual-testing-code","toc":["introduction","component-explorers","workflow","vtdd","automate","conclusion"],"title":"Visual Testing Handbook","twitterShareText":"I’m learning how to visual test UIs with Storybook! It’s great for finding UI bugs automatically."}},"site":{"siteMetadata":{"title":"Storybook Tutorials","githubUrl":"https://github.com/chromaui/learnstorybook.com","contributeUrl":"https://github.com/chromaui/learnstorybook.com/#contribute","permalink":"https://storybook.js.org/tutorials","siteUrl":"https://storybook.js.org"}},"tocPages":{"edges":[{"node":{"frontmatter":{"tocTitle":"자동화","title":"시각적 테스트 자동화","description":"회귀 오류를 잡기 위해 시각적 테스트를 자동화하기"},"fields":{"slug":"/visual-testing-handbook/react/ko/automate/","framework":"react","chapter":"automate"}}},{"node":{"frontmatter":{"tocTitle":"컴포넌트 탐색기","title":"컴포넌트 탐색기","description":"UI 개발과 시각적 테스팅을 위한 도구"},"fields":{"slug":"/visual-testing-handbook/react/ko/component-explorer/","framework":"react","chapter":"component-explorer"}}},{"node":{"frontmatter":{"tocTitle":"마무리","title":"마무리","description":"시각적 버그들에 안녕을"},"fields":{"slug":"/visual-testing-handbook/react/ko/conclusion/","framework":"react","chapter":"conclusion"}}},{"node":{"frontmatter":{"tocTitle":"소개","title":"시각적 테스팅 소개","description":"UI를 테스트하는 실용적인 방법"},"fields":{"slug":"/visual-testing-handbook/react/ko/introduction/","framework":"react","chapter":"introduction"}}},{"node":{"frontmatter":{"tocTitle":null,"title":"시각적 TDD","description":"첫 번째 시각적 테스트를 만들어보세요"},"fields":{"slug":"/visual-testing-handbook/react/ko/vtdd/","framework":"react","chapter":"vtdd"}}},{"node":{"frontmatter":{"tocTitle":null,"title":"작업 흐름(Work Flow)","description":"컴포넌트 설계를 위한 테스트 주도(test-driven) 작업 흐름(workflow)"},"fields":{"slug":"/visual-testing-handbook/react/ko/workflow/","framework":"react","chapter":"workflow"}}}]},"translationPages":{"edges":[{"node":{"frontmatter":{"tocTitle":"Automate","title":"Automate visual testing","description":"Automate visual testing to catch regressions"},"fields":{"slug":"/visual-testing-handbook/react/en/automate/","framework":"react","chapter":"automate","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Component explorers","title":"Component explorers","description":"A tool for UI development and visual testing"},"fields":{"slug":"/visual-testing-handbook/react/en/component-explorers/","framework":"react","chapter":"component-explorers","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Conclusion","title":"Conclusion","description":"Say bye to visual bugs"},"fields":{"slug":"/visual-testing-handbook/react/en/conclusion/","framework":"react","chapter":"conclusion","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Introduction","title":"Introduction to visual testing","description":"The pragmatic way to test user interfaces"},"fields":{"slug":"/visual-testing-handbook/react/en/introduction/","framework":"react","chapter":"introduction","language":"en"}}},{"node":{"frontmatter":{"tocTitle":null,"title":"Visual TDD","description":"Write your first visual tests"},"fields":{"slug":"/visual-testing-handbook/react/en/vtdd/","framework":"react","chapter":"vtdd","language":"en"}}},{"node":{"frontmatter":{"tocTitle":null,"title":"Workflow","description":"A test-driven workflow for building components"},"fields":{"slug":"/visual-testing-handbook/react/en/workflow/","framework":"react","chapter":"workflow","language":"en"}}},{"node":{"frontmatter":{"tocTitle":"Automatizar","title":"Automatizar las pruebas visuales","description":"Automatice las pruebas visuales para detectar regresiones"},"fields":{"slug":"/visual-testing-handbook/react/es/automate/","framework":"react","chapter":"automate","language":"es"}}},{"node":{"frontmatter":{"tocTitle":"Exploradores de componentes","title":"Exploradores de componentes","description":"Una herramienta para el desarrollo de la UI y las pruebas visuales"},"fields":{"slug":"/visual-testing-handbook/react/es/component-explorers/","framework":"react","chapter":"component-explorers","language":"es"}}},{"node":{"frontmatter":{"tocTitle":"Conclusión","title":"Conclusión","description":"Di adiós a los errores visuales"},"fields":{"slug":"/visual-testing-handbook/react/es/conclusion/","framework":"react","chapter":"conclusion","language":"es"}}},{"node":{"frontmatter":{"tocTitle":"Introducción","title":"Introducción a las pruebas visuales","description":"La manera pragmática de probar interfaces de usuario"},"fields":{"slug":"/visual-testing-handbook/react/es/introduction/","framework":"react","chapter":"introduction","language":"es"}}},{"node":{"frontmatter":{"tocTitle":null,"title":"TDD Visual","description":"Escribe tus primeras pruebas visuales"},"fields":{"slug":"/visual-testing-handbook/react/es/vtdd/","framework":"react","chapter":"vtdd","language":"es"}}},{"node":{"frontmatter":{"tocTitle":null,"title":"Flujo de trabajo","description":"Un flujo de trabajo guiado por pruebas para la construcción de componentes"},"fields":{"slug":"/visual-testing-handbook/react/es/workflow/","framework":"react","chapter":"workflow","language":"es"}}},{"node":{"frontmatter":{"tocTitle":"자동화","title":"시각적 테스트 자동화","description":"회귀 오류를 잡기 위해 시각적 테스트를 자동화하기"},"fields":{"slug":"/visual-testing-handbook/react/ko/automate/","framework":"react","chapter":"automate","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"컴포넌트 탐색기","title":"컴포넌트 탐색기","description":"UI 개발과 시각적 테스팅을 위한 도구"},"fields":{"slug":"/visual-testing-handbook/react/ko/component-explorer/","framework":"react","chapter":"component-explorer","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"마무리","title":"마무리","description":"시각적 버그들에 안녕을"},"fields":{"slug":"/visual-testing-handbook/react/ko/conclusion/","framework":"react","chapter":"conclusion","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":"소개","title":"시각적 테스팅 소개","description":"UI를 테스트하는 실용적인 방법"},"fields":{"slug":"/visual-testing-handbook/react/ko/introduction/","framework":"react","chapter":"introduction","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":null,"title":"시각적 TDD","description":"첫 번째 시각적 테스트를 만들어보세요"},"fields":{"slug":"/visual-testing-handbook/react/ko/vtdd/","framework":"react","chapter":"vtdd","language":"ko"}}},{"node":{"frontmatter":{"tocTitle":null,"title":"작업 흐름(Work Flow)","description":"컴포넌트 설계를 위한 테스트 주도(test-driven) 작업 흐름(workflow)"},"fields":{"slug":"/visual-testing-handbook/react/ko/workflow/","framework":"react","chapter":"workflow","language":"ko"}}}]}},"pageContext":{"guide":"visual-testing-handbook","slug":"/visual-testing-handbook/react/ko/automate/","framework":"react","language":"ko","chapter":"automate","pageType":"chapter"}},"staticQueryHashes":["238248339"]}